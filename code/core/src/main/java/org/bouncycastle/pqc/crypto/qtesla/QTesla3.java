package org.bouncycastle.pqc.crypto.qtesla;

import java.security.SecureRandom;

import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

class QTesla3
{

    private static final int GENERATOR_A = 38;
    private static final int INVERSE_NUMBER_THEORETIC_TRANSFORM = 237839;
    private static final int PARAM_N = 1024;
    private static final int PARAM_H = 48;
    private static final int Q = 8404993;
    private static final long Q_INVERSE = 4034936831L;
    private static final int Q_LOGARITHM = 24;
    private static final int B = 2097151;
    private static final int B_BIT = 21;
    private static final int D = 22;
    private static final int KEY_GENERATOR_BOUND_S = 1233;
    private static final int U = KEY_GENERATOR_BOUND_S;
    private static final int KEY_GENERATOR_BOUND_E = 1147;
    private static final int REJECTION = KEY_GENERATOR_BOUND_E;
    private static final int BARRETT_MULTIPLICATION = 511;
    private static final int BARRETT_DIVISION = 32;

    private static final int S_BIT = 9;
    private static final int R = 15873;


    private static final int CRYPTO_SEEDBYTES = 32;
    private static final int HASH = 32;

    private static final int CRYPTO_RANDOMBYTES = 32;
    private static final int CRYPTO_C_BYTES = 32;
    private static final int HM_BYTES = 64;

    static final int CRYPTO_BYTES = ((PARAM_N * (B_BIT + 1) + 7) / 8 + CRYPTO_C_BYTES);
    static final int CRYPTO_SECRETKEYBYTES = (2 * S_BIT * PARAM_N / 8 + 2 * CRYPTO_SEEDBYTES);

    static final int CRYPTO_PUBLICKEYBYTES = ((PARAM_N * Q_LOGARITHM + 7) / 8 + CRYPTO_SEEDBYTES);


    static final int[] ZETA = {            /* 1024-Entry */
        4751355, 3795849, 4203855, 2135008, 6005859, 8231721, 5028848, 2129664,
        7697675, 4755217, 4725508, 3239612, 6448681, 1076080, 3836135, 157994,
        5620931, 7886062, 2890907, 5218426, 5961785, 6266756, 6428554, 5190121,
        4542230, 1731429, 2223635, 4784194, 3466184, 2050685, 6391390, 2917454,
        2117568, 5724978, 3127077, 96284, 5251989, 3298678, 7201703, 432021,
        540694, 6011377, 6511091, 6136825, 215125, 6152822, 4121955, 6320948,
        4723419, 3116754, 3645529, 4643271, 3249093, 3697259, 965302, 3790255,
        413429, 835404, 7555714, 4708344, 980578, 8245349, 3583234, 5891188,
        510086, 5483952, 4214513, 7522675, 1382737, 8097349, 2423268, 1978286,
        5820434, 2985005, 1002240, 3252040, 5584283, 4027445, 3761478, 571563,
        7926529, 5265675, 4705738, 1136608, 2087977, 4856723, 7896505, 2504130,
        4175968, 5245926, 3848909, 3723902, 2181242, 6476735, 5922041, 2555482,
        6087709, 1106974, 975919, 978505, 666303, 510879, 5043449, 4402981,
        4204183, 6947226, 3519239, 7237093, 2533941, 1259684, 4897608, 2422013,
        5398162, 3551190, 6378523, 1066751, 5216741, 6557683, 7171180, 7736022,
        7762004, 7816398, 434930, 5685531, 7776512, 2136107, 4689096, 2604202,
        981324, 6730872, 7113462, 4313227, 5315069, 2687514, 6464663, 6622027,
        4919554, 3137828, 6662263, 180027, 1225049, 993103, 6035200, 4768729,
        7594608, 7982166, 1506084, 1412996, 7294988, 6493396, 3679803, 707143,
        5016089, 5893370, 7746168, 8284307, 2196442, 4506697, 5744441, 8155374,
        2335696, 3358969, 4559736, 8378847, 7396599, 5613912, 5146767, 5609330,
        7478110, 7007768, 1540167, 2082109, 4395136, 2443, 1730472, 6785605,
        3689430, 7862069, 5994777, 2079150, 1569788, 3575961, 2449565, 7637802,
        3223577, 7636917, 7014221, 3206599, 1033702, 2788915, 2962522, 5785994,
        2935623, 8040165, 646639, 6994735, 1576929, 4976182, 1923760, 7349612,
        7767222, 5695773, 2143434, 1957445, 6164911, 6325092, 3612819, 5415356,
        6956649, 426840, 6748291, 3530533, 2487417, 7851363, 3671732, 7201581,
        4717139, 4328822, 5046010, 6056773, 997476, 3549222, 1616322, 3335537,
        2012692, 7475529, 2140630, 167787, 3791455, 3347958, 1263751, 2818658,
        8280316, 4667491, 7207537, 6918648, 6602507, 1441518, 5135376, 1610367,
        1016061, 6841480, 1841539, 2809077, 5412381, 1240493, 4442913, 2092171,
        530239, 4308557, 3094305, 18124, 7247221, 5096652, 6892131, 3384856,
        1435046, 3360331, 4908655, 1534384, 724138, 4632705, 7021901, 776577,
        6462800, 658408, 6767742, 6323190, 163450, 3090558, 8264681, 6113406,
        2256514, 2002774, 4157811, 1055743, 4272701, 50782, 506820, 2425609,
        6121916, 7048118, 7211758, 7436523, 7921267, 8219231, 2113012, 5561555,
        5402793, 6238877, 2785469, 6601179, 5379488, 8247469, 7039082, 8122949,
        4032315, 7719142, 6412117, 1765474, 1423373, 3702073, 6814517, 4539579,
        3714409, 3581714, 4818181, 4950204, 6549391, 6746510, 1332314, 6200219,
        4026957, 4085009, 6474721, 6328096, 8097370, 821395, 4479068, 6408341,
        1730278, 3865108, 131998, 3351400, 4527559, 4193606, 1952686, 3339484,
        549242, 3890467, 3314638, 2970830, 7867854, 235273, 4948941, 3082658,
        6487691, 6448908, 3822702, 5156099, 3762420, 359477, 1160634, 2545064,
        2616573, 343964, 1277910, 8113538, 5564704, 6944366, 2663139, 2516714,
        7942808, 5983628, 6727371, 7839582, 4671024, 5279277, 2488251, 5096610,
        7584873, 1054559, 3389302, 5410955, 2700464, 7113783, 1182446, 681631,
        7959149, 1325409, 3882231, 4559, 7653722, 2600940, 4354328, 6155200,
        8125241, 629708, 1056841, 5566349, 6779032, 7067599, 5284661, 693330,
        7111640, 6054764, 513663, 3702555, 3667331, 8053262, 3156410, 3207020,
        6096921, 3226364, 425916, 1538990, 398369, 155207, 5962206, 3895624,
        3506460, 4470299, 8132637, 7313282, 1829556, 3023684, 7819374, 258083,
        4547318, 6274233, 4376026, 630321, 5354666, 3252030, 3347795, 5465400,
        424523, 5150532, 4329513, 5096843, 2541091, 4590781, 5698802, 5642789,
        6737542, 6616826, 6654175, 1804189, 2843875, 5019191, 2161010, 1581450,
        7289320, 4525144, 2861293, 1184843, 6181826, 3408399, 6954125, 5897789,
        899044, 983144, 996950, 2489509, 387143, 6743865, 6535741, 5316114,
        2464958, 6452453, 6588356, 7749117, 3100483, 5451553, 6683005, 6153131,
        2627493, 3750459, 6016367, 1854681, 5732487, 5756336, 8222984, 6286073,
        4805023, 4851345, 5346259, 2571898, 7886466, 915166, 750162, 7786158,
        3314583, 3691654, 8162728, 2964553, 934173, 2078087, 5894912, 103974,
        2087696, 8074875, 5687948, 6220280, 5741269, 3408244, 5908533, 5524440,
        405672, 2691224, 4107404, 1478212, 5069278, 1307718, 2701016, 5020579,
        3281802, 173449, 7661012, 6737317, 2871182, 7099172, 8035102, 4259638,
        676548, 1986555, 2711904, 72486, 1537417, 4903843, 6366739, 2767425,
        4405806, 3939004, 6029482, 7042007, 7145803, 4423846, 5865280, 6985580,
        4890457, 5525519, 3020926, 5286410, 2507470, 164000, 7418741, 3860720,
        464246, 7532333, 2980645, 2208123, 1971493, 7819798, 4391480, 3562255,
        1579560, 3499404, 3220123, 5084410, 2287245, 6505523, 7780056, 63470,
        7361152, 6336292, 3791465, 1891129, 6121738, 6215206, 578317, 2487175,
        2862407, 7213504, 175006, 850302, 4374314, 3335934, 5070337, 6404001,
        6073674, 8339498, 2024643, 590809, 3871922, 7695009, 3420134, 2417242,
        2441851, 510359, 6415975, 5966400, 1511640, 3278055, 7552659, 7251424,
        299565, 4631182, 923500, 4565103, 1774136, 1514014, 504288, 7611114,
        348434, 6179273, 6103289, 5512004, 6204874, 4163633, 4030619, 5442160,
        5517078, 4979705, 1450139, 4955279, 6892996, 1378796, 7049658, 7482552,
        2773460, 3700106, 5637962, 1306126, 1342831, 2876039, 2004802, 7911534,
        7811881, 7092783, 2948733, 3985770, 4334975, 2089910, 4202878, 5889243,
        2572806, 7276150, 3116397, 4610309, 4197207, 4524762, 3158380, 712800,
        7767402, 2288328, 3468435, 4486610, 3258256, 4642983, 4397184, 3897150,
        3551813, 5337205, 7602723, 882125, 4202004, 8272524, 4429435, 2663261,
        1849803, 4271342, 947283, 5290695, 2673376, 7191822, 2383684, 5913757,
        1682056, 4777883, 695434, 2390033, 5758581, 3482483, 6148624, 4372212,
        1400527, 3325425, 3100142, 7502466, 6912369, 6564003, 187779, 6691298,
        1850484, 1886083, 496958, 4353128, 6385269, 7972087, 3249950, 1216051,
        2945392, 1716654, 974864, 2073675, 4221586, 3197564, 5970107, 2900682,
        1387771, 1054897, 5018658, 4773826, 2772495, 3056563, 3437397, 1151634,
        3999643, 4238788, 2370183, 7770204, 2300657, 4762800, 4526771, 4778855,
        6276244, 2113067, 4081453, 4596532, 896126, 1589159, 5012357, 1884715,
        3849142, 1866468, 1032092, 4847686, 5661618, 424095, 6396824, 6683872,
        1861112, 2415218, 7008299, 7999725, 61635, 7831813, 1934052, 1635771,
        5857904, 3890446, 3661009, 4427825, 1472600, 2675631, 3142762, 2889031,
        6246428, 3402870, 890885, 300722, 6084442, 6218398, 6764876, 198422,
        5203148, 1220540, 3348691, 7973167, 1045857, 5930282, 7686549, 4965437,
        2645402, 3029580, 1825802, 4844838, 5808305, 3553948, 2913430, 4640069,
        3231039, 5061776, 3388089, 5793791, 5210767, 6179591, 3259669, 208882,
        7981542, 8176212, 8044267, 4362411, 8164807, 3882310, 4575856, 1654989,
        2265125, 4993003, 1845358, 876204, 4604356, 6572234, 3709582, 2495322,
        7769694, 925160, 5211127, 3071339, 8271814, 1715113, 5979772, 8317560,
        2452182, 4560530, 2756321, 7541123, 2085235, 2131014, 7043807, 945796,
        1043611, 2220162, 1519639, 1881321, 4596482, 136652, 8225264, 4442429,
        3140394, 4274467, 2235364, 3403641, 181254, 2256107, 5402447, 274444,
        2450384, 774651, 1007857, 488393, 7305342, 8006923, 6213033, 6045031,
        7357074, 3686418, 2069641, 4827274, 6134510, 8182850, 6622239, 4957796,
        5001496, 2676491, 2165891, 4258696, 1805202, 5978874, 5892091, 3081817,
        8351892, 2919790, 6813596, 1226235, 7874664, 1597662, 445691, 7699844,
        517985, 5142533, 583275, 2942212, 2005170, 2781492, 5325095, 5840485,
        5904531, 1652696, 462001, 488382, 1483208, 3583371, 3903552, 4338246,
        8102054, 4607027, 3097235, 5461223, 878707, 5641705, 3004044, 6269117,
        8310809, 1068150, 3754674, 7419023, 2389012, 2672920, 7033357, 3299934,
        5696831, 8333890, 6870124, 4248890, 7451238, 2996873, 969409, 4748469,
        6761147, 7334152, 4608897, 6381766, 593469, 5060352, 7663929, 3490012,
        5639842, 804562, 3554683, 1275119, 2464713, 584123, 1282802, 869246,
        1698712, 460380, 2270294, 1082297, 5755881, 4164200, 3083595, 7232256,
        6669791, 5297513, 7888160, 305159, 4943995, 4839451, 4607217, 4607189,
        4027370, 6773057, 2930951, 7228212, 4930292, 5787132, 6979166, 3679768,
        2488882, 7434774, 6751191, 4901863, 601751, 3772392, 4470584, 3139313,
        2581011, 5344571, 2578160, 126930, 4080823, 5594812, 3191131, 2170321,
        4703512, 3837804, 7417071, 2996858, 6019670, 5239573, 1770901, 7113857,
        5965467, 8008016, 192380, 7790747, 867783, 2310931, 477474, 723267,
        2025346, 7474446, 1992778, 5665730, 5375937, 1925098, 1772156, 7957977,
        7842750, 4780661, 1703317, 4165961, 5256458, 4850569, 4937646, 1616991,
        8229940, 128563, 1160620, 5109082, 4794032, 4890146, 4147576, 7912097,
        927266, 450684, 7302719, 2598976, 5529718, 1041149, 4841395, 6276135,
        7825395, 7621671, 6329777, 1955851, 6040427, 1035300, 2855476, 3258870,
        3396861, 5274746, 2777694, 3359337, 4493563, 561924, 7215951, 2907115,
        4547697, 5403413, 7025806, 2453538, 4137455, 971005, 4298903, 1271923,
        7150549, 2833306, 8021667, 7587207, 833119, 2919663, 5306176, 659188,
        4708953, 3799478, 5584025, 7305039, 5709959, 3562365, 965949, 15873
    };

    static final int[] ZETA_INVERSE = {    /* 1024-Entry */
        7439044, 4842628, 2695034, 1099954, 2820968, 4605515, 3696040, 7745805,
        3098817, 5485330, 7571874, 817786, 383326, 5571687, 1254444, 7133070,
        4106090, 7433988, 4267538, 5951455, 1379187, 3001580, 3857296, 5497878,
        1189042, 7843069, 3911430, 5045656, 5627299, 3130247, 5008132, 5146123,
        5549517, 7369693, 2364566, 6449142, 2075216, 783322, 579598, 2128858,
        3563598, 7363844, 2875275, 5806017, 1102274, 7954309, 7477727, 492896,
        4257417, 3514847, 3610961, 3295911, 7244373, 8276430, 175053, 6788002,
        3467347, 3554424, 3148535, 4239032, 6701676, 3624332, 562243, 447016,
        6632837, 6479895, 3029056, 2739263, 6412215, 930547, 6379647, 7681726,
        7927519, 6094062, 7537210, 614246, 8212613, 396977, 2439526, 1291136,
        6634092, 3165420, 2385323, 5408135, 987922, 4567189, 3701481, 6234672,
        5213862, 2810181, 4324170, 8278063, 5826833, 3060422, 5823982, 5265680,
        3934409, 4632601, 7803242, 3503130, 1653802, 970219, 5916111, 4725225,
        1425827, 2617861, 3474701, 1176781, 5474042, 1631936, 4377623, 3797804,
        3797776, 3565542, 3460998, 8099834, 516833, 3107480, 1735202, 1172737,
        5321398, 4240793, 2649112, 7322696, 6134699, 7944613, 6706281, 7535747,
        7122191, 7820870, 5940280, 7129874, 4850310, 7600431, 2765151, 4914981,
        741064, 3344641, 7811524, 2023227, 3796096, 1070841, 1643846, 3656524,
        7435584, 5408120, 953755, 4156103, 1534869, 71103, 2708162, 5105059,
        1371636, 5732073, 6015981, 985970, 4650319, 7336843, 94184, 2135876,
        5400949, 2763288, 7526286, 2943770, 5307758, 3797966, 302939, 4066747,
        4501441, 4821622, 6921785, 7916611, 7942992, 6752297, 2500462, 2564508,
        3079898, 5623501, 6399823, 5462781, 7821718, 3262460, 7887008, 705149,
        7959302, 6807331, 530329, 7178758, 1591397, 5485203, 53101, 5323176,
        2512902, 2426119, 6599791, 4146297, 6239102, 5728502, 3403497, 3447197,
        1782754, 222143, 2270483, 3577719, 6335352, 4718575, 1047919, 2359962,
        2191960, 398070, 1099651, 7916600, 7397136, 7630342, 5954609, 8130549,
        3002546, 6148886, 8223739, 5001352, 6169629, 4130526, 5264599, 3962564,
        179729, 8268341, 3808511, 6523672, 6885354, 6184831, 7361382, 7459197,
        1361186, 6273979, 6319758, 863870, 5648672, 3844463, 5952811, 87433,
        2425221, 6689880, 133179, 5333654, 3193866, 7479833, 635299, 5909671,
        4695411, 1832759, 3800637, 7528789, 6559635, 3411990, 6139868, 6750004,
        3829137, 4522683, 240186, 4042582, 360726, 228781, 423451, 8196111,
        5145324, 2225402, 3194226, 2611202, 5016904, 3343217, 5173954, 3764924,
        5491563, 4851045, 2596688, 3560155, 6579191, 5375413, 5759591, 3439556,
        718444, 2474711, 7359136, 431826, 5056302, 7184453, 3201845, 8206571,
        1640117, 2186595, 2320551, 8104271, 7514108, 5002123, 2158565, 5515962,
        5262231, 5729362, 6932393, 3977168, 4743984, 4514547, 2547089, 6769222,
        6470941, 573180, 8343358, 405268, 1396694, 5989775, 6543881, 1721121,
        2008169, 7980898, 2743375, 3557307, 7372901, 6538525, 4555851, 6520278,
        3392636, 6815834, 7508867, 3808461, 4323540, 6291926, 2128749, 3626138,
        3878222, 3642193, 6104336, 634789, 6034810, 4166205, 4405350, 7253359,
        4967596, 5348430, 5632498, 3631167, 3386335, 7350096, 7017222, 5504311,
        2434886, 5207429, 4183407, 6331318, 7430129, 6688339, 5459601, 7188942,
        5155043, 432906, 2019724, 4051865, 7908035, 6518910, 6554509, 1713695,
        8217214, 1840990, 1492624, 902527, 5304851, 5079568, 7004466, 4032781,
        2256369, 4922510, 2646412, 6014960, 7709559, 3627110, 6722937, 2491236,
        6021309, 1213171, 5731617, 3114298, 7457710, 4133651, 6555190, 5741732,
        3975558, 132469, 4202989, 7522868, 802270, 3067788, 4853180, 4507843,
        4007809, 3762010, 5146737, 3918383, 4936558, 6116665, 637591, 7692193,
        5246613, 3880231, 4207786, 3794684, 5288596, 1128843, 5832187, 2515750,
        4202115, 6315083, 4070018, 4419223, 5456260, 1312210, 593112, 493459,
        6400191, 5528954, 7062162, 7098867, 2767031, 4704887, 5631533, 922441,
        1355335, 7026197, 1511997, 3449714, 6954854, 3425288, 2887915, 2962833,
        4374374, 4241360, 2200119, 2892989, 2301704, 2225720, 8056559, 793879,
        7900705, 6890979, 6630857, 3839890, 7481493, 3773811, 8105428, 1153569,
        852334, 5126938, 6893353, 2438593, 1989018, 7894634, 5963142, 5987751,
        4984859, 709984, 4533071, 7814184, 6380350, 65495, 2331319, 2000992,
        3334656, 5069059, 4030679, 7554691, 8229987, 1191489, 5542586, 5917818,
        7826676, 2189787, 2283255, 6513864, 4613528, 2068701, 1043841, 8341523,
        624937, 1899470, 6117748, 3320583, 5184870, 4905589, 6825433, 4842738,
        4013513, 585195, 6433500, 6196870, 5424348, 872660, 7940747, 4544273,
        986252, 8240993, 5897523, 3118583, 5384067, 2879474, 3514536, 1419413,
        2539713, 3981147, 1259190, 1362986, 2375511, 4465989, 3999187, 5637568,
        2038254, 3501150, 6867576, 8332507, 5693089, 6418438, 7728445, 4145355,
        369891, 1305821, 5533811, 1667676, 743981, 8231544, 5123191, 3384414,
        5703977, 7097275, 3335715, 6926781, 4297589, 5713769, 7999321, 2880553,
        2496460, 4996749, 2663724, 2184713, 2717045, 330118, 6317297, 8301019,
        2510081, 6326906, 7470820, 5440440, 242265, 4713339, 5090410, 618835,
        7654831, 7489827, 518527, 5833095, 3058734, 3553648, 3599970, 2118920,
        182009, 2648657, 2672506, 6550312, 2388626, 4654534, 5777500, 2251862,
        1721988, 2953440, 5304510, 655876, 1816637, 1952540, 5940035, 3088879,
        1869252, 1661128, 8017850, 5915484, 7408043, 7421849, 7505949, 2507204,
        1450868, 4996594, 2223167, 7220150, 5543700, 3879849, 1115673, 6823543,
        6243983, 3385802, 5561118, 6600804, 1750818, 1788167, 1667451, 2762204,
        2706191, 3814212, 5863902, 3308150, 4075480, 3254461, 7980470, 2939593,
        5057198, 5152963, 3050327, 7774672, 4028967, 2130760, 3857675, 8146910,
        585619, 5381309, 6575437, 1091711, 272356, 3934694, 4898533, 4509369,
        2442787, 8249786, 8006624, 6866003, 7979077, 5178629, 2308072, 5197973,
        5248583, 351731, 4737662, 4702438, 7891330, 2350229, 1293353, 7711663,
        3120332, 1337394, 1625961, 2838644, 7348152, 7775285, 279752, 2249793,
        4050665, 5804053, 751271, 8400434, 4522762, 7079584, 445844, 7723362,
        7222547, 1291210, 5704529, 2994038, 5015691, 7350434, 820120, 3308383,
        5916742, 3125716, 3733969, 565411, 1677622, 2421365, 462185, 5888279,
        5741854, 1460627, 2840289, 291455, 7127083, 8061029, 5788420, 5859929,
        7244359, 8045516, 4642573, 3248894, 4582291, 1956085, 1917302, 5322335,
        3456052, 8169720, 537139, 5434163, 5090355, 4514526, 7855751, 5065509,
        6452307, 4211387, 3877434, 5053593, 8272995, 4539885, 6674715, 1996652,
        3925925, 7583598, 307623, 2076897, 1930272, 4319984, 4378036, 2204774,
        7072679, 1658483, 1855602, 3454789, 3586812, 4823279, 4690584, 3865414,
        1590476, 4702920, 6981620, 6639519, 1992876, 685851, 4372678, 282044,
        1365911, 157524, 3025505, 1803814, 5619524, 2166116, 3002200, 2843438,
        6291981, 185762, 483726, 968470, 1193235, 1356875, 2283077, 5979384,
        7898173, 8354211, 4132292, 7349250, 4247182, 6402219, 6148479, 2291587,
        140312, 5314435, 8241543, 2081803, 1637251, 7746585, 1942193, 7628416,
        1383092, 3772288, 7680855, 6870609, 3496338, 5044662, 6969947, 5020137,
        1512862, 3308341, 1157772, 8386869, 5310688, 4096436, 7874754, 6312822,
        3962080, 7164500, 2992612, 5595916, 6563454, 1563513, 7388932, 6794626,
        3269617, 6963475, 1802486, 1486345, 1197456, 3737502, 124677, 5586335,
        7141242, 5057035, 4613538, 8237206, 6264363, 929464, 6392301, 5069456,
        6788671, 4855771, 7407517, 2348220, 3358983, 4076171, 3687854, 1203412,
        4733261, 553630, 5917576, 4874460, 1656702, 7978153, 1448344, 2989637,
        4792174, 2079901, 2240082, 6447548, 6261559, 2709220, 637771, 1055381,
        6481233, 3428811, 6828064, 1410258, 7758354, 364828, 5469370, 2618999,
        5442471, 5616078, 7371291, 5198394, 1390772, 768076, 5181416, 767191,
        5955428, 4829032, 6835205, 6325843, 2410216, 542924, 4715563, 1619388,
        6674521, 8402550, 4009857, 6322884, 6864826, 1397225, 926883, 2795663,
        3258226, 2791081, 1008394, 26146, 3845257, 5046024, 6069297, 249619,
        2660552, 3898296, 6208551, 120686, 658825, 2511623, 3388904, 7697850,
        4725190, 1911597, 1110005, 6991997, 6898909, 422827, 810385, 3636264,
        2369793, 7411890, 7179944, 8224966, 1742730, 5267165, 3485439, 1782966,
        1940330, 5717479, 3089924, 4091766, 1291531, 1674121, 7423669, 5800791,
        3715897, 6268886, 628481, 2719462, 7970063, 588595, 642989, 668971,
        1233813, 1847310, 3188252, 7338242, 2026470, 4853803, 3006831, 5982980,
        3507385, 7145309, 5871052, 1167900, 4885754, 1457767, 4200810, 4002012,
        3361544, 7894114, 7738690, 7426488, 7429074, 7298019, 2317284, 5849511,
        2482952, 1928258, 6223751, 4681091, 4556084, 3159067, 4229025, 5900863,
        508488, 3548270, 6317016, 7268385, 3699255, 3139318, 478464, 7833430,
        4643515, 4377548, 2820710, 5152953, 7402753, 5419988, 2584559, 6426707,
        5981725, 307644, 7022256, 882318, 4190480, 2921041, 7894907, 2513805,
        4821759, 159644, 7424415, 3696649, 849279, 7569589, 7991564, 4614738,
        7439691, 4707734, 5155900, 3761722, 4759464, 5288239, 3681574, 2084045,
        4283038, 2252171, 8189868, 2268168, 1893902, 2393616, 7864299, 7972972,
        1203290, 5106315, 3153004, 8308709, 5277916, 2680015, 6287425, 5487539,
        2013603, 6354308, 4938809, 3620799, 6181358, 6673564, 3862763, 3214872,
        1976439, 2138237, 2443208, 3186567, 5514086, 518931, 2784062, 8246999,
        4568858, 7328913, 1956312, 5165381, 3679485, 3649776, 707318, 6275329,
        3376145, 173272, 2399134, 6269985, 4201138, 4609144, 3653638, 8389120

    };


    /**
     * Description:	Generates A Signature for A Given Message According to the Ring-TESLA Signature Scheme for Heuristic qTESLA Security Category-1 and
     * Security Category-3 (Option for Size or Speed)
     *
     * @param message       Message to be Signed
     * @param messageOffset Starting Point of the Message to be Signed
     * @param messageLength Length of the Message to be Signed
     * @param signature     Output Package Containing Signature
     * @param privateKey    Private Key
     * @param secureRandom  Source of Randomness
     * @return 0                                    Successful Execution
     */
    static int signing(

        byte[] signature,
        final byte[] message, int messageOffset, int messageLength,
        final byte[] privateKey, SecureRandom secureRandom
    )
    {

        byte[] C = new byte[CRYPTO_C_BYTES];
        byte[] randomness = new byte[CRYPTO_SEEDBYTES];
        byte[] randomnessInput = new byte[CRYPTO_RANDOMBYTES + CRYPTO_SEEDBYTES + HM_BYTES];
        byte[] seed = new byte[CRYPTO_SEEDBYTES * 2];
        byte[] temporaryRandomnessInput = new byte[CRYPTO_RANDOMBYTES];
        int[] positionList = new int[PARAM_H];
        short[] signList = new short[PARAM_H];
        short[] secretPolynomial = new short[PARAM_N];
        short[] errorPolynomial = new short[PARAM_N];

        int[] A = new int[PARAM_N];
        int[] V = new int[PARAM_N];
        int[] Y = new int[PARAM_N];
        int[] Z = new int[PARAM_N];
        int[] SC = new int[PARAM_N];
        int[] EC = new int[PARAM_N];

        /* Domain Separator for Sampling Y */
        int nonce = 0;

        decodePrivateKey(seed, secretPolynomial, errorPolynomial, privateKey);


        secureRandom.nextBytes(temporaryRandomnessInput);
        System.arraycopy(temporaryRandomnessInput, 0, randomnessInput, CRYPTO_RANDOMBYTES, CRYPTO_RANDOMBYTES);

        System.arraycopy(seed, CRYPTO_SEEDBYTES, randomnessInput, 0, CRYPTO_SEEDBYTES);


        HashUtils.secureHashAlgorithmKECCAK256(
            randomnessInput, CRYPTO_RANDOMBYTES + CRYPTO_SEEDBYTES, HM_BYTES, message, 0, messageLength);

        HashUtils.secureHashAlgorithmKECCAK256(
            randomness, 0, CRYPTO_SEEDBYTES, randomnessInput, 0, CRYPTO_RANDOMBYTES + CRYPTO_SEEDBYTES + HM_BYTES);


        QTesla3Polynomial.polynomialUniform(A, seed, 0);


        /* Loop Due to Possible Rejection */
        while (true)
        {

            /* Sample Y Uniformly Random from -B to B */
            sampleY(Y, randomness, 0, ++nonce); //n, q, b, bBit);

            /* V = A * Y Modulo Q */
            QTesla3Polynomial.polynomialMultiplication(V, A, Y, PARAM_N, Q, Q_INVERSE, ZETA);

            hashFunction(C, 0, V, randomnessInput, CRYPTO_RANDOMBYTES + CRYPTO_SEEDBYTES); //, n, d, q);

            /* Generate C = EncodeC (C') Where C' is the Hashing of V Together with Message */
            encodeC(positionList, signList, C, 0);

            QTesla3Polynomial.sparsePolynomialMultiplication16(SC, secretPolynomial, positionList, signList);

            /* Z = Y + EC Modulo Q */
            QTesla3Polynomial.polynomialAddition(Z, Y, SC, PARAM_N);

            /* Rejection Sampling */
            if (testRejection(Z)) // PARAM_N, b, u))
            {

                continue;

            }

            QTesla3Polynomial.sparsePolynomialMultiplication16(EC, errorPolynomial, positionList, signList);

            /* V = V - EC modulo Q */
            QTesla3Polynomial.polynomialSubtractionCorrection(V, V, EC);

            if (testV(V, REJECTION))
            {
                continue;
            }

            /* Pack Signature */
            encodeSignature(signature, 0, C, 0, Z);


            return 0;

        }

    }


    /*************************************************************************************************************************************************************************************************************
     * Description:	Encode Signature for Heuristic qTESLA Security Category-3 (Option for Speed)
     *
     * @param        signature            Output Package Containing Signature
     * @param        signatureOffset        Starting Point of the Output Package Containing Signature
     * @param        C
     * @param        cOffset
     * @param        Z
     *
     * @return none
     *************************************************************************************************************************************************************************************************************/
    static void encodeSignature(byte[] signature, int signatureOffset, byte[] C, int cOffset, int[] Z)
    {

        int j = 0;

        for (int i = 0; i < (PARAM_N * D / 32); i += D / 2)
        {

            store32(signature, signatureOffset + 4 * (i + 0), (int)(((Z[j + 0] & ((1 << 22) - 1))) | (Z[j + 1] << 22)));
            store32(signature, signatureOffset + 4 * (i + 1), (int)((((Z[j + 1] >>> 10) & ((1 << 12) - 1))) | (Z[j + 2] << 12)));
            store32(signature, signatureOffset + 4 * (i + 2), (int)(((Z[j + 2] >>> 20) & ((1 << 2) - 1)) | ((Z[j + 3] & ((1 << 22) - 1)) << 2) | (Z[j + 4] << 24)));
            store32(signature, signatureOffset + 4 * (i + 3), (int)((((Z[j + 4] >>> 8) & ((1 << 14) - 1))) | (Z[j + 5] << 14)));
            store32(signature, signatureOffset + 4 * (i + 4), (int)(((Z[j + 5] >>> 18) & ((1 << 4) - 1)) | ((Z[j + 6] & ((1 << 22) - 1)) << 4) | (Z[j + 7] << 26)));
            store32(signature, signatureOffset + 4 * (i + 5), (int)((((Z[j + 7] >>> 6) & ((1 << 16) - 1))) | (Z[j + 8] << 16)));
            store32(signature, signatureOffset + 4 * (i + 6), (int)(((Z[j + 8] >>> 16) & ((1 << 6) - 1)) | ((Z[j + 9] & ((1 << 22) - 1)) << 6) | (Z[j + 10] << 28)));
            store32(signature, signatureOffset + 4 * (i + 7), (int)((((Z[j + 10] >>> 4) & ((1 << 18) - 1))) | (Z[j + 11] << 18)));
            store32(signature, signatureOffset + 4 * (i + 8), (int)(((Z[j + 11] >>> 14) & ((1 << 8) - 1)) | ((Z[j + 12] & ((1 << 22) - 1)) << 8) | (Z[j + 13] << 30)));
            store32(signature, signatureOffset + 4 * (i + 9), (int)((((Z[j + 13] >>> 2) & ((1 << 20) - 1))) | (Z[j + 14] << 20)));
            store32(signature, signatureOffset + 4 * (i + 10), (int)((((Z[j + 14] >>> 12) & ((1 << 10) - 1))) | (Z[j + 15] << 10)));

            j += 32 / 2;

        }

        System.arraycopy(C, cOffset, signature, signatureOffset + PARAM_N * D / 8, HASH);

    }


    private static boolean testRejection(int[] Z) //, int n, int b, int u)
    {

        int valid = 0;

        for (int i = 0; i < PARAM_N; i++)
        {
            valid |= (B - U) - absolute(Z[i]);

        }

        return (valid >>> 31) > 0;

    }

    private static int absolute(int value)
    {

        return ((value >> 31) ^ value) - (value >> 31);

    }

    private static long absolute(long value)
    {

        return ((value >> 63) ^ value) - (value >> 63);

    }

    private static boolean testRejection(long[] Z) //, int n, int b, int u)
    {
        long valid = 0;
        for (int i = 0; i < PARAM_N; i++)
        {
            valid |= (B - U) - absolute(Z[i]);
        }

        return (valid >>> 63) > 0;

    }

    private static void hashFunction(byte[] output, int outputOffset, int[] V, final byte[] message, int messageOffset) //, int n, int d, int q)
    {

        int mask;
        int cL;

        byte[] T = new byte[PARAM_N + HM_BYTES];

        for (int i = 0; i < PARAM_N; i++)
        {
            /* If V[i] > Q / 2 Then V[i] = V[i] - Q */
            mask = (Q / 2 - V[i]) >> 31;
            V[i] = ((V[i] - Q) & mask) | (V[i] & (~mask));
            cL = V[i] & ((1 << D) - 1);
            /* If cL > 2 ^ (d - 1) Then cL = cL - 2 ^ d */
            mask = ((1 << (D - 1)) - cL) >> 31;
            cL = ((cL - (1 << D)) & mask) | (cL & (~mask));
            T[i] = (byte)((V[i] - cL) >> D);

        }

        System.arraycopy(message, messageOffset, T, PARAM_N, HM_BYTES);
        HashUtils.secureHashAlgorithmKECCAK256(output, outputOffset, HASH, T, 0, PARAM_N + HM_BYTES);

    }

    private static boolean testV(int[] V, int rejection) //  int n, int d, int q,
    {

        int mask;
        int left;
        int right;
        int test1;
        int test2;

        for (int i = 0; i < PARAM_N; i++)
        {

            mask = (Q / 2 - V[i]) >> 31;
            right = ((V[i] - Q) & mask) | (V[i] & (~mask));
            test1 = (~(absolute(right) - (Q / 2 - rejection))) >>> 31;
            left = right;
            right = (right + (1 << (D - 1)) - 1) >> D;
            right = left - (right << D);
            test2 = (~(absolute(right) - ((1 << (D - 1)) - rejection))) >>> 31;

            /* Two Tests Fail */
            if ((test1 | test2) == 1)
            {
                return true;
            }

        }

        return false;

    }


    /*********************************************************************************************************************************
     * Description:	Extracts the Original Message and Checks Whether the Generated Signature is Valid for A Given Signature Package
     * 				for Heuristic qTESLA Security Category-1 and Security Category-3 (Option for Size of Speed)
     *
     * @param        signature                            Given Signature Package
     * @param        signatureOffset                        Starting Point of the Given Signature Package
     * @param        signatureLength                        Length of the Given Signature Package
     * @param        message                                Original (Signed) Message
     * @param        publicKey                            Public Key

     *
     * @return 0                                    Valid Signature
     * 				< 0									Invalid Signature
     *********************************************************************************************************************************/
    static int verifying(

        byte[] message,
        final byte[] signature, int signatureOffset, int signatureLength,
        final byte[] publicKey)
    {

        byte[] C = new byte[HASH];
        byte[] cSignature = new byte[HASH];
        byte[] seed = new byte[CRYPTO_SEEDBYTES];
        byte[] hashMessage = new byte[HM_BYTES];
        int[] newPublicKey = new int[PARAM_N];

        int[] positionList = new int[PARAM_N];
        short[] signList = new short[PARAM_H];

        int[] W = new int[PARAM_N];
        int[] Z = new int[PARAM_N];
        int[] TC = new int[PARAM_N];
        int[] A = new int[PARAM_N];

        if (signatureLength < CRYPTO_BYTES)
        {
            return -1;
        }


        decodeSignature(C, Z, signature, signatureOffset);
        /* Check Norm of Z */
        if (testZ(Z))
        {
            return -2;
        }

        decodePublicKey(newPublicKey, seed, 0, publicKey);
        QTesla3Polynomial.polynomialUniform(A, seed, 0);

        encodeC(positionList, signList, C, 0);

        /* W = A * Z - TC */
        QTesla3Polynomial.sparsePolynomialMultiplication32(TC, newPublicKey, positionList, signList);
        QTesla3Polynomial.polynomialMultiplication(W, A, Z, PARAM_N, Q, Q_INVERSE, ZETA);

        QTesla3Polynomial.polynomialSubtractionMontgomery(W, W, TC);

        HashUtils.secureHashAlgorithmKECCAK256(
            hashMessage, 0, HM_BYTES, message, 0, message.length
        );

        /* Obtain the Hash Symbol */
        hashFunction(cSignature, 0, W, hashMessage, 0); // n, d, q);

        /* Check if Same With One from Signature */
        if (!memoryEqual(C, 0, cSignature, 0, HASH))
        {
            return -3;
        }

        return 0;

    }

    /**********************************************************************************
     * Description:	Checks Bounds for Signature Vector Z During Signature Verification
     * 				for Heuristic qTESLA Security Category-1 and Security Category-3
     * 				(Option of Size of Speed)
     *
     * @param        Z        Signature Vector
     *
     * @return false    Valid / Accepted
     * 				true	Invalid / Rejected
     *********************************************************************************/
    private static boolean testZ(int[] Z)
    {

        for (int i = 0; i < PARAM_N; i++)
        {

            if ((Z[i] < -(B - U)) || (Z[i] > B - U))
            {

                return true;

            }

        }

        return false;

    }

    /*************************************************************************************
     * Description:	Checks Bounds for Signature Vector Z During Signature Verification
     * 				for Provably-Secure qTESLA Security Category-1 and Security Category-3
     *
     * @param        Z        Signature Vector

     * @return false    Valid / Accepted
     * 				true	Invalid / Rejected
     *************************************************************************************/
    private static boolean testZ(long[] Z)
    {

        for (int i = 0; i < PARAM_N; i++)
        {

            if ((Z[i] < -(B - U)) || (Z[i] > B - U))
            {

                return true;

            }

        }

        return false;

    }

    /******************************************************************************************************************************
     * Description:	Decode Signature for Heuristic qTESLA Security Category-1 and Category-3 (Option for Size)
     *
     * @param    C
     * @param    Z
     * @param    signature            Output Package Containing Signature
     * @param    signatureOffset        Starting Point of the Output Package Containing Signature
     *
     * @return none
     ******************************************************************************************************************************/
    static void decodeSignature(byte[] C, int[] Z, final byte[] signature, int signatureOffset)
    {

        int j = 0;

        for (int i = 0; i < PARAM_N; i += 16)
        {

            Z[i] = (at(signature, j, 0) << 10) >> 10;
            Z[i + 1] = (at(signature, j, 0) >>> 22) | ((at(signature, j, 1) << 20) >> 10);
            Z[i + 2] = (at(signature, j, 1) >>> 12) | ((at(signature, j, 2) << 30) >> 10);
            Z[i + 3] = (at(signature, j, 2) << 8) >> 10;
            Z[i + 4] = (at(signature, j, 2) >>> 24) | ((at(signature, j, 3) << 18) >> 10);
            Z[i + 5] = (at(signature, j, 3) >>> 14) | ((at(signature, j, 4) << 28) >> 10);
            Z[i + 6] = (at(signature, j, 4) << 6) >> 10;
            Z[i + 7] = (at(signature, j, 4) >>> 26) | ((at(signature, j, 5) << 16) >> 10);
            Z[i + 8] = (at(signature, j, 5) >>> 16) | ((at(signature, j, 6) << 26) >> 10);
            Z[i + 9] = (at(signature, j, 6) << 4) >> 10;
            Z[i + 10] = (at(signature, j, 6) >>> 28) | ((at(signature, j, 7) << 14) >> 10);
            Z[i + 11] = (at(signature, j, 7) >>> 18) | ((at(signature, j, 8) << 24) >> 10);
            Z[i + 12] = (at(signature, j, 8) << 2) >> 10;
            Z[i + 13] = (at(signature, j, 8) >>> 30) | ((at(signature, j, 9) << 12) >> 10);
            Z[i + 14] = (at(signature, j, 9) >>> 20) | ((at(signature, j, 10) << 22) >> 10);
            Z[i + 15] = at(signature, j, 10) >> 10;
            j += 11;

        }

        System.arraycopy(signature, signatureOffset + PARAM_N * D / 8, C, 0, HASH);

    }


    static void encodePrivateKey(byte[] privateKey, final int[] secretPolynomial, final int[] errorPolynomial, final byte[] seed, int seedOffset)
    {
        byte[] sk = privateKey;
        int[] s = secretPolynomial;
        int[] e = errorPolynomial;

        int j = 0;

        for (int i = 0; i < PARAM_N; i += 8)
        {
            sk[j + 0] = (byte)s[i + 0];
            sk[j + 1] = (byte)(((s[i + 0] >> 8) & 0x01) | (s[i + 1] << 1));
            sk[j + 2] = (byte)(((s[i + 1] >> 7) & 0x03) | (s[i + 2] << 2));
            sk[j + 3] = (byte)(((s[i + 2] >> 6) & 0x07) | (s[i + 3] << 3));
            sk[j + 4] = (byte)(((s[i + 3] >> 5) & 0x0F) | (s[i + 4] << 4));
            sk[j + 5] = (byte)(((s[i + 4] >> 4) & 0x1F) | (s[i + 5] << 5));
            sk[j + 6] = (byte)(((s[i + 5] >> 3) & 0x3F) | (s[i + 6] << 6));
            sk[j + 7] = (byte)(((s[i + 6] >> 2) & 0x7F) | (s[i + 7] << 7));
            sk[j + 8] = (byte)(s[i + 7] >> 1);

            j += 9;
        }

        for (int i = 0; i < PARAM_N; i += 8)
        {
            sk[j + 0] = (byte)e[i + 0];
            sk[j + 1] = (byte)(((e[i + 0] >> 8) & 0x01) | (e[i + 1] << 1));
            sk[j + 2] = (byte)(((e[i + 1] >> 7) & 0x03) | (e[i + 2] << 2));
            sk[j + 3] = (byte)(((e[i + 2] >> 6) & 0x07) | (e[i + 3] << 3));
            sk[j + 4] = (byte)(((e[i + 3] >> 5) & 0x0F) | (e[i + 4] << 4));
            sk[j + 5] = (byte)(((e[i + 4] >> 4) & 0x1F) | (e[i + 5] << 5));
            sk[j + 6] = (byte)(((e[i + 5] >> 3) & 0x3F) | (e[i + 6] << 6));
            sk[j + 7] = (byte)(((e[i + 6] >> 2) & 0x7F) | (e[i + 7] << 7));
            sk[j + 8] = (byte)(e[i + 7] >> 1);
            j += 9;
        }

        System.arraycopy(seed, seedOffset, privateKey, PARAM_N * S_BIT * 2 / 8, CRYPTO_SEEDBYTES * 2);

    }


    static void decodePrivateKey(byte[] seed, short[] secretPolynomial, short[] errorPolynomial, final byte[] privateKey)
    {

        int j = 0;
        int temporary = 0;


        for (int i = 0; i < PARAM_N; i += 8)
        {

            secretPolynomial[i + 0] = (short)((privateKey[j + 0] & 0xFF) | ((privateKey[j + 1] & 0xFF) << 31) >> 23);
            secretPolynomial[i + 1] = (short)(((privateKey[j + 1] & 0xFF) >>> 1) | ((privateKey[j + 2] & 0xFF) << 30) >> 23);
            secretPolynomial[i + 2] = (short)(((privateKey[j + 2] & 0xFF) >>> 2) | ((privateKey[j + 3] & 0xFF) << 29) >> 23);
            secretPolynomial[i + 3] = (short)(((privateKey[j + 3] & 0xFF) >>> 3) | ((privateKey[j + 4] & 0xFF) << 28) >> 23);
            secretPolynomial[i + 4] = (short)(((privateKey[j + 4] & 0xFF) >>> 4) | ((privateKey[j + 5] & 0xFF) << 27) >> 23);
            secretPolynomial[i + 5] = (short)(((privateKey[j + 5] & 0xFF) >>> 5) | ((privateKey[j + 6] & 0xFF) << 26) >> 23);
            secretPolynomial[i + 6] = (short)(((privateKey[j + 6] & 0xFF) >>> 6) | ((privateKey[j + 7] & 0xFF) << 25) >> 23);
            secretPolynomial[i + 7] = (short)(((privateKey[j + 7] & 0xFF) >>> 7) | (privateKey[j + 8] << 1)); // j+8 is to be treated as signed.

            j += 9;
        }

        for (int i = 0; i < PARAM_N; i += 8)
        {
            errorPolynomial[i + 0] = (short)((privateKey[j + 0] & 0xFF) | ((privateKey[j + 1] & 0xFF) << 31) >> 23);
            errorPolynomial[i + 1] = (short)(((privateKey[j + 1] & 0xFF) >>> 1) | ((privateKey[j + 2] & 0xFF) << 30) >> 23);
            errorPolynomial[i + 2] = (short)(((privateKey[j + 2] & 0xFF) >>> 2) | ((privateKey[j + 3] & 0xFF) << 29) >> 23);
            errorPolynomial[i + 3] = (short)(((privateKey[j + 3] & 0xFF) >>> 3) | ((privateKey[j + 4] & 0xFF) << 28) >> 23);
            errorPolynomial[i + 4] = (short)(((privateKey[j + 4] & 0xFF) >>> 4) | ((privateKey[j + 5] & 0xFF) << 27) >> 23);
            errorPolynomial[i + 5] = (short)(((privateKey[j + 5] & 0xFF) >>> 5) | ((privateKey[j + 6] & 0xFF) << 26) >> 23);
            errorPolynomial[i + 6] = (short)(((privateKey[j + 6] & 0xFF) >>> 6) | ((privateKey[j + 7] & 0xFF) << 25) >> 23);
            errorPolynomial[i + 7] = (short)(((privateKey[j + 7] & 0xFF) >>> 7) | (privateKey[j + 8] << 1)); // j+8 to be treated as signed.


            j += 9;
        }

        System.arraycopy(privateKey, PARAM_N * S_BIT * 2 / 8, seed, 0, CRYPTO_SEEDBYTES * 2);


    }


    static void encodePublicKey(byte[] publicKey, final int[] T, final byte[] seedA, int seedAOffset)
    {

        int j = 0;


        for (int i = 0; i < PARAM_N * Q_LOGARITHM / 32; i += Q_LOGARITHM)
        {
            at(publicKey, i, 0, ((T[j] | (T[j + 1] << 24))));
            at(publicKey, i, 1, ((T[j + 1] >>> 8) | (T[j + 2] << 16)));
            at(publicKey, i, 2, ((T[j + 2] >>> 16) | (T[j + 3] << 8)));
            at(publicKey, i, 3, (T[j + 4] | (T[j + 5] << 24)));
            at(publicKey, i, 4, (T[j + 5] >>> 8) | (T[j + 6] << 16));
            at(publicKey, i, 5, (T[j + 6] >>> 16) | (T[j + 7] << 8));
            at(publicKey, i, 6, (T[j + 8] | (T[j + 9] << 24)));
            at(publicKey, i, 7, (T[j + 9] >>> 8) | (T[j + 10] << 16));
            at(publicKey, i, 8, ((T[j + 10] >>> 16) | (T[j + 11] << 8)));
            at(publicKey, i, 9, T[j + 12] | (T[j + 13] << 24));
            at(publicKey, i, 10, (T[j + 13] >>> 8) | (T[j + 14] << 16));
            at(publicKey, i, 11, (T[j + 14] >>> 16) | (T[j + 15] << 8));
            at(publicKey, i, 12, T[j + 16] | (T[j + 17] << 24));
            at(publicKey, i, 13, (T[j + 17] >>> 8) | (T[j + 18] << 16));
            at(publicKey, i, 14, (T[j + 18] >>> 16) | (T[j + 19] << 8));
            at(publicKey, i, 15, (T[j + 20] | (T[j + 21] << 24)));
            at(publicKey, i, 16, ((T[j + 21] >>> 8) | (T[j + 22] << 16)));
            at(publicKey, i, 17, ((T[j + 22] >>> 16) | (T[j + 23] << 8)));
            at(publicKey, i, 18, (T[j + 24] | (T[j + 25] << 24)));
            at(publicKey, i, 19, ((T[j + 25] >>> 8) | (T[j + 26] << 16)));
            at(publicKey, i, 20, ((T[j + 26] >>> 16) | (T[j + 27] << 8)));
            at(publicKey, i, 21, (T[j + 28] | (T[j + 29] << 24)));
            at(publicKey, i, 22, ((T[j + 29] >>> 8) | (T[j + 30] << 16)));
            at(publicKey, i, 23, ((T[j + 30] >>> 16) | (T[j + 31] << 8)));
            j += 32;
        }

        System.arraycopy(seedA, seedAOffset, publicKey, PARAM_N * Q_LOGARITHM / 8, CRYPTO_SEEDBYTES);

    }


    private static void at(byte[] bs, int base, int index, int value)
    {
        org.bouncycastle.util.Pack.intToLittleEndian(value, bs, (base * 4) + (index * 4));
    }

    private static int at(byte[] bs, int base, int index)
    {
        int off = (base * 4) + (index * 4);

        int n = bs[off] & 0xff;
        n |= (bs[++off] & 0xff) << 8;
        n |= (bs[++off] & 0xff) << 16;
        n |= bs[++off] << 24;
        return n;
    }

    static void decodePublicKey(int[] publicKey, byte[] seedA, int seedAOffset, final byte[] publicKeyInput)
    {

        int j = 0;

        int maskq = (1 << Q_LOGARITHM) - 1;


        for (int i = 0; i < PARAM_N; i += 32)
        {
            publicKey[i + 0] = (at(publicKeyInput, j, 0)) & maskq;
            publicKey[i + 1] = ((at(publicKeyInput, j, 0) >>> 24) | (at(publicKeyInput, j, 1) << 8)) & maskq;
            publicKey[i + 2] = ((at(publicKeyInput, j, 1) >>> 16) | (at(publicKeyInput, j, 2) << 16)) & maskq;
            publicKey[i + 3] = ((at(publicKeyInput, j, 2) >>> 8)) & maskq;
            publicKey[i + 4] = (at(publicKeyInput, j, 3)) & maskq;
            publicKey[i + 5] = ((at(publicKeyInput, j, 3) >>> 24) | (at(publicKeyInput, j, 4) << 8)) & maskq;
            publicKey[i + 6] = ((at(publicKeyInput, j, 4) >>> 16) | (at(publicKeyInput, j, 5) << 16)) & maskq;
            publicKey[i + 7] = ((at(publicKeyInput, j, 5) >>> 8)) & maskq;
            publicKey[i + 8] = (at(publicKeyInput, j, 6)) & maskq;
            publicKey[i + 9] = ((at(publicKeyInput, j, 6) >>> 24) | (at(publicKeyInput, j, 7) << 8)) & maskq;
            publicKey[i + 10] = ((at(publicKeyInput, j, 7) >>> 16) | (at(publicKeyInput, j, 8) << 16)) & maskq;
            publicKey[i + 11] = ((at(publicKeyInput, j, 8) >>> 8)) & maskq;
            publicKey[i + 12] = (at(publicKeyInput, j, 9)) & maskq;
            publicKey[i + 13] = ((at(publicKeyInput, j, 9) >>> 24) | (at(publicKeyInput, j, 10) << 8)) & maskq;
            publicKey[i + 14] = ((at(publicKeyInput, j, 10) >>> 16) | (at(publicKeyInput, j, 11) << 16)) & maskq;
            publicKey[i + 15] = ((at(publicKeyInput, j, 11) >>> 8)) & maskq;
            publicKey[i + 16] = (at(publicKeyInput, j, 12)) & maskq;
            publicKey[i + 17] = ((at(publicKeyInput, j, 12) >>> 24) | (at(publicKeyInput, j, 13) << 8)) & maskq;
            publicKey[i + 18] = ((at(publicKeyInput, j, 13) >>> 16) | (at(publicKeyInput, j, 14) << 16)) & maskq;
            publicKey[i + 19] = ((at(publicKeyInput, j, 14) >>> 8)) & maskq;
            publicKey[i + 20] = (at(publicKeyInput, j, 15)) & maskq;
            publicKey[i + 21] = ((at(publicKeyInput, j, 15) >>> 24) | (at(publicKeyInput, j, 16) << 8)) & maskq;
            publicKey[i + 22] = ((at(publicKeyInput, j, 16) >>> 16) | (at(publicKeyInput, j, 17) << 16)) & maskq;
            publicKey[i + 23] = ((at(publicKeyInput, j, 17) >>> 8)) & maskq;
            publicKey[i + 24] = (at(publicKeyInput, j, 18)) & maskq;
            publicKey[i + 25] = ((at(publicKeyInput, j, 18) >>> 24) | (at(publicKeyInput, j, 19) << 8)) & maskq;
            publicKey[i + 26] = ((at(publicKeyInput, j, 19) >>> 16) | (at(publicKeyInput, j, 20) << 16)) & maskq;
            publicKey[i + 27] = ((at(publicKeyInput, j, 20) >>> 8)) & maskq;
            publicKey[i + 28] = (at(publicKeyInput, j, 21)) & maskq;
            publicKey[i + 29] = ((at(publicKeyInput, j, 21) >>> 24) | (at(publicKeyInput, j, 22) << 8)) & maskq;
            publicKey[i + 30] = ((at(publicKeyInput, j, 22) >>> 16) | (at(publicKeyInput, j, 23) << 16)) & maskq;
            publicKey[i + 31] = ((at(publicKeyInput, j, 23) >>> 8)) & maskq;
            j += Q_LOGARITHM;
        }

        System.arraycopy(publicKeyInput, PARAM_N * Q_LOGARITHM / 8, seedA, seedAOffset, CRYPTO_SEEDBYTES);

    }

    /******************************************************************************************************************
     * Description:	Samples Polynomial Y, Such That Each Coefficient is in the Range [-B, B], for Heuristic qTESLA
     * 				Security Category-1 and Security Category-3 (Option for Size or Speed)
     *
     * @param        Y                Polynomial Y
     * @param        seed            Kappa-Bit Seed
     * @param        seedOffset        Starting Point of the Kappa-Bit Seed
     * @param        nonce            Domain Separator for Error Polynomial and Secret Polynomial
     *
     * @return none
     ******************************************************************************************************************/
    static void sampleY(int[] Y, final byte[] seed, int seedOffset, int nonce) //   int n, int b, int bBit)
    {

        int i = 0;
        int position = 0;
        int numberOfByte = (B_BIT + 1 + 7) / 8;
        int numberOfBlock = PARAM_N;
        byte[] buffer = new byte[PARAM_N * numberOfByte];
        int[] y = new int[4];

        short dualModeSampler = (short)(nonce << 8);

//        if (q == Parameter.Q_I)
//        {
//
//            HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(
//                buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, QTesla3Polynomial.RANDOM
//            );
//
//        }

//        if (q == Parameter.Q_III_SIZE || q == Parameter.Q_III_SPEED)
//        {

        HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(
            buffer, 0, PARAM_N * numberOfByte, dualModeSampler++, seed, seedOffset, CRYPTO_RANDOMBYTES
        );


        //}

        while (i < PARAM_N)
        {

            if (position >= numberOfBlock * numberOfByte * 4)
            {
                numberOfBlock =
                    HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE /
                        ((B_BIT + 1 + 7) / 8);

                HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(
                    buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE,
                    dualModeSampler++,
                    seed, seedOffset, CRYPTO_RANDOMBYTES
                );

                position = 0;

            }

            y[0] = (load32(buffer, position) & ((1 << (B_BIT + 1)) - 1)) - B;
            y[1] = (load32(buffer, position + numberOfByte) & ((1 << (B_BIT + 1)) - 1)) - B;
            y[2] = (load32(buffer, position + numberOfByte * 2) & ((1 << (B_BIT + 1)) - 1)) - B;
            y[3] = (load32(buffer, position + numberOfByte * 3) & ((1 << (B_BIT + 1)) - 1)) - B;

            if (i < PARAM_N && y[0] != (1 << B_BIT))
            {

                Y[i++] = y[0];

            }

            if (i < PARAM_N && y[1] != (1 << B_BIT))
            {

                Y[i++] = y[1];

            }

            if (i < PARAM_N && y[2] != (1 << B_BIT))
            {

                Y[i++] = y[2];

            }

            if (i < PARAM_N && y[3] != (1 << B_BIT))
            {

                Y[i++] = y[3];

            }

            position += numberOfByte * 4;

        }

    }

    /*************************************************************************************************************************
     * Description:	Encoding of C' by Mapping the Output of the Hash Function H to An N-Element Vector with Entries {-1, 0, 1}
     *
     * @param        positionList            {0, ..., n - 1} ^ h
     * @param        signList            {-1, +1} ^ h
     * @param        output                Result of the Hash Function H
     * @param        outputOffset        Starting Point of the Result of the Hash Function H
     *
     * @return none
     *************************************************************************************************************************/
    static void encodeC(int[] positionList, short[] signList, byte[] output, int outputOffset)
    {

        int count = 0;
        int position;
        short domainSeparator = 0;
        short[] C = new short[PARAM_N];
        byte[] randomness = new byte[HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE];

        /* Use the Hash Value as Key to Generate Some Randomness */
        HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(
            randomness, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE,
            domainSeparator++,
            output, outputOffset, CRYPTO_RANDOMBYTES
        );

        /* Use Rejection Sampling to Determine Positions to be Set in the New Vector */
        Arrays.fill(C, (short)0);

        /* Sample A Unique Position k times.
         * Use Two Bytes
         */
        for (int i = 0; i < PARAM_H; )
        {

            if (count > HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE - 3)
            {

                HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(
                    randomness, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE,
                    domainSeparator++,
                    output, outputOffset, CRYPTO_RANDOMBYTES
                );

                count = 0;

            }

            position = (randomness[count] << 8) | (randomness[count + 1] & 0xFF);
            position &= (PARAM_N - 1);

            /* Position is between [0, n - 1] and Has not Been Set Yet
             * Determine Signature
             */
            if (C[position] == 0)
            {

                if ((randomness[count + 2] & 1) == 1)
                {

                    C[position] = -1;

                }
                else
                {

                    C[position] = 1;

                }

                positionList[i] = position;
                signList[i] = C[position];
                i++;

            }

            count += 3;

        }

    }

    /************************************************************************************************************************************************************
     * Description:	Generates A Pair of Public Key and Private Key for qTESLA Signature Scheme for Heuristic qTESLA Security Category-1 and Security Category-3
     *				(Option for Size or Speed)
     *
     * @param        publicKey                            Contains Public Key
     * @param        privateKey                            Contains Private Key
     * @param        secureRandom                        Source of Randomness
     *
     * @return 0                                    Successful Execution
     ************************************************************************************************************************************************************/
    static int generateKeyPair(

        byte[] publicKey, byte[] privateKey, SecureRandom secureRandom)
    {

        /* Initialize Domain Separator for Error Polynomial and Secret Polynomial */
        int nonce = 0;

        byte[] randomness = new byte[CRYPTO_RANDOMBYTES];

        /* Extend Random Bytes to Seed Generation of Error Polynomial and Secret Polynomial */
        byte[] randomnessExtended = new byte[CRYPTO_SEEDBYTES * 4];

        int[] secretPolynomial = new int[PARAM_N];
        int[] errorPolynomial = new int[PARAM_N];
        int[] A = new int[PARAM_N];
        int[] T = new int[PARAM_N];

        /* Get randomnessExtended <- seedErrorPolynomial, seedSecretPolynomial, seedA, seedY */
        // this.rng.randomByte (randomness, (short) 0, QTesla3Polynomial.RANDOM);
        secureRandom.nextBytes(randomness);


        HashUtils.secureHashAlgorithmKECCAK256(randomnessExtended, 0, CRYPTO_SEEDBYTES * 4, randomness, 0, CRYPTO_RANDOMBYTES);


        /*
         * Sample the Error Polynomial Fulfilling the Criteria
         * Choose All Error Polynomial in R with Entries from D_SIGMA
         * Repeat Step at Iteration if the h Largest Entries of Error Polynomial Summation to L_E
         */
        do
        {
            sample_gauss_poly(++nonce, randomnessExtended, 0, errorPolynomial);
        }
        while (checkPolynomial(errorPolynomial, KEY_GENERATOR_BOUND_E));



        /*
         * Sample the Secret Polynomial Fulfilling the Criteria
         * Choose Secret Polynomial in R with Entries from D_SIGMA
         * Repeat Step if the h Largest Entries of Secret Polynomial Summation to L_S
         */
        do
        {

            sample_gauss_poly(++nonce, randomnessExtended, CRYPTO_SEEDBYTES, secretPolynomial);

            //Sample.polynomialGaussSamplerI(secretPolynomial, 0, randomnessExtended, QTesla3Polynomial.CRYPTO_SEEDBYTES, ++nonce);
        }
        while (checkPolynomial(secretPolynomial, KEY_GENERATOR_BOUND_S));


        /* Generate Uniform Polynomial A */
        QTesla3Polynomial.polynomialUniform(A, randomnessExtended, CRYPTO_SEEDBYTES * 2);

        /* Compute the Public Key T = A * secretPolynomial + errorPolynomial */
        QTesla3Polynomial.polynomialMultiplication(T, A, secretPolynomial, PARAM_N, Q, Q_INVERSE, ZETA);
        QTesla3Polynomial.polynomialAdditionCorrection(T, T, errorPolynomial, PARAM_N, Q);

        /* Pack Public and Private Keys */

        encodePublicKey(publicKey, T, randomnessExtended, CRYPTO_SEEDBYTES * 2);

        encodePrivateKey(privateKey, secretPolynomial, errorPolynomial, randomnessExtended, CRYPTO_SEEDBYTES * 2);


        return 0;

    }

    /**********************************************************************************************************
     * Description:	Checks Whether the Generated Error Polynomial or the Generated Secret Polynomial
     *				Fulfills Certain Properties Needed in Key Generation Algorithm
     *				For Heuristic qTESLA Security Category-1 and Security Category-3 (Option for Size or Speed)
     *
     * @param        polynomial        Parameter to be Checked
     * @param        bound            Threshold of Summation
     *
     * @return false            Fulfillment
     * 				true			No Fulfillment
     **********************************************************************************************************/
    private static boolean checkPolynomial(int[] polynomial, int bound)
    {

        int i, j, sum = 0, limit = PARAM_N;
        int temp, mask;
        int[] list = new int[PARAM_N];

        for (j = 0; j < PARAM_N; j++)
        {
            list[j] = absolute(polynomial[j]);
        }

        for (j = 0; j < PARAM_H; j++)
        {
            for (i = 0; i < limit - 1; i++)
            {
                // If list[i+1] > list[i] then exchange contents
                mask = (list[i + 1] - list[i]) >> (RADIX32 - 1);
                temp = (list[i + 1] & mask) | (list[i] & ~mask);
                list[i + 1] = (list[i] & mask) | (list[i + 1] & ~mask);
                list[i] = temp;
            }
            sum += list[limit - 1];
            limit -= 1;
        }

        return (sum > bound);
//        {
//            return 1;
//        } else
//        {
//            r eturn 0;
//        }


        /*
        int summation = 0;
        int limit = PARAM_N;
        int temporary;
        int mask;
        int[] list = new int[PARAM_N];

        for (int i = 0; i < PARAM_N; i++)
        {

            list[i] = absolute(polynomial[i]);

        }

        for (int i = 0; i < PARAM_H; i++)
        {

            for (int j = 0; j < limit - 1; j++)
            {
                /* If list[j + 1] > list[j] Then Exchanges Contents */
           /*
                mask = (list[j + 1] - list[j]) >> 31;
                temporary = (list[j + 1] & mask) | (list[j] & (~mask));
                list[j + 1] = (list[j] & mask) | (list[j + 1] & (~mask));
                list[j] = temporary;

            }

            summation += list[limit - 1];
            limit--;

        }

        if (summation > bound)
        {

            return true;

        }

        return false;
*/
    }


    private static void sample_gauss_poly(int nonce, byte[] randomnessExtended, int randomOffset, int[] poly)
    {
        int dmsp = nonce << 8;

        for (int chunk = 0; chunk < PARAM_N; chunk += CHUNK_SIZE)
        {
            kmxGauss(poly, chunk, randomnessExtended, randomOffset, dmsp++);
        }

    }


    private static int CHUNK_SIZE = 512;
    private static int CDT_ROWS = 133;
    private static int CDT_COLS = 4;
    private static int RADIX32 = 32;
    private static int RADIX = 32; // As per C code..

    private static long[] cdt_v = new long[]{
        0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L, // 0
        0x05019F23L, 0x215AA886L, 0x266BD84AL, 0x1962528BL, // 1
        0x0EF8936EL, 0x23BFC791L, 0x31B19042L, 0x50351AA0L, // 2
        0x18CB03FCL, 0x0746C256L, 0x407022E8L, 0x334F94BBL, // 3
        0x2261C15EL, 0x4527ABF1L, 0x7CCF6441L, 0x00EF6D46L, // 4
        0x2BA749FEL, 0x4A371856L, 0x3A2CA997L, 0x5153CB0AL, // 5
        0x3488598AL, 0x0435B2D7L, 0x4DD990AEL, 0x0E7429C0L, // 6
        0x3CF45E22L, 0x01E1BF49L, 0x4CFF5AEEL, 0x26AE280CL, // 7
        0x44DDCECBL, 0x5BEB1ED9L, 0x2BD797BFL, 0x29192D65L, // 8
        0x4C3A608EL, 0x22F7BD95L, 0x7BAF5E4AL, 0x611E8A2EL, // 9
        0x530319A4L, 0x2AAB68C5L, 0x135B9B19L, 0x7D19FFA3L, // 10
        0x59344411L, 0x6FBA748BL, 0x4409DF71L, 0x76C2A4C2L, // 11
        0x5ECD42A3L, 0x12258E6CL, 0x70ABD8BFL, 0x33F8D6F8L, // 12
        0x63D04CBCL, 0x4B03A25AL, 0x17893AFDL, 0x00512D3CL, // 13
        0x68421661L, 0x279CDBF3L, 0x64BB398DL, 0x603BDA52L, // 14
        0x6C296A64L, 0x58D40125L, 0x5D5E3204L, 0x45948D03L, // 15
        0x6F8EBCDCL, 0x2CBC9B6CL, 0x078DBD24L, 0x11153742L, // 16
        0x727BBBA2L, 0x6464E481L, 0x6C03A4A4L, 0x4FBBF658L, // 17
        0x74FAE221L, 0x32614E4BL, 0x4B399625L, 0x5284D9C8L, // 18
        0x771714BEL, 0x64DE7817L, 0x5BAFF2C0L, 0x3A75B026L, // 19
        0x78DB474CL, 0x64906B4AL, 0x36C15D1AL, 0x49AAA0FCL, // 20
        0x7A5230BFL, 0x213597F2L, 0x3ECC4E7BL, 0x5FFE21CAL, // 21
        0x7B860D68L, 0x0DD17AC2L, 0x34CE2917L, 0x13D0DE15L, // 22
        0x7C806FFEL, 0x7068EFBDL, 0x603BDD00L, 0x24292429L, // 23
        0x7D4A20E9L, 0x2D5BC71BL, 0x470F64CEL, 0x63129FAFL, // 24
        0x7DEB0A96L, 0x00A6501CL, 0x4C461A13L, 0x790CAB86L, // 25
        0x7E6A3144L, 0x75C93242L, 0x16023571L, 0x06B7110BL, // 26
        0x7ECDB456L, 0x661A7E35L, 0x162E551AL, 0x75DB9DA9L, // 27
        0x7F1AD71FL, 0x20516B1FL, 0x5FF00AE2L, 0x43DFF254L, // 28
        0x7F560F41L, 0x3300DE7CL, 0x4B8F0799L, 0x5C3E4574L, // 29
        0x7F8316C3L, 0x1226EADBL, 0x51D0E0B1L, 0x5870949BL, // 30
        0x7FA5003CL, 0x3183FE96L, 0x56A3015DL, 0x5471CE29L, // 31
        0x7FBE4BCBL, 0x237FBE88L, 0x06124F61L, 0x189877D0L, // 32
        0x7FD0FBBEL, 0x4900A57BL, 0x1231A728L, 0x21713D51L, // 33
        0x7FDEA82DL, 0x4264689CL, 0x090BD52BL, 0x35B3EF58L, // 34
        0x7FE890F4L, 0x7F427C59L, 0x3FEA77A7L, 0x76B5CEC4L, // 35
        0x7FEFADC9L, 0x235461F2L, 0x76530FE7L, 0x458AFED6L, // 36
        0x7FF4BC39L, 0x47D62996L, 0x080C04AEL, 0x5578E91DL, // 37
        0x7FF84BA5L, 0x449EAC84L, 0x43D826FAL, 0x01AFCF15L, // 38
        0x7FFAC73EL, 0x68B27237L, 0x1032E3F9L, 0x63DED628L, // 39
        0x7FFC7E40L, 0x6CDCE391L, 0x74D2C6E0L, 0x56F439FAL, // 40
        0x7FFDAA93L, 0x2A0A579FL, 0x4E3FD638L, 0x555547D0L, // 41
        0x7FFE760EL, 0x7D0DA319L, 0x04AE9E8DL, 0x47F8B424L, // 42
        0x7FFEFE9CL, 0x00E6F118L, 0x5B12C69BL, 0x63045184L, // 43
        0x7FFF595EL, 0x1329625AL, 0x788CC79FL, 0x61B72C9CL, // 44
        0x7FFF951CL, 0x7C94755BL, 0x7F1054DFL, 0x57D6E351L, // 45
        0x7FFFBC11L, 0x0D63DD99L, 0x16E1DEEDL, 0x5FA47FD6L, // 46
        0x7FFFD538L, 0x56FC93F8L, 0x4BF6F51DL, 0x65D1F42FL, // 47
        0x7FFFE54FL, 0x26D25196L, 0x4AF51374L, 0x7A3F204DL, // 48
        0x7FFFEF80L, 0x25C7892BL, 0x5FC036B7L, 0x563D2EF5L, // 49
        0x7FFFF5E5L, 0x17797BB9L, 0x4AED0883L, 0x55F4708EL, // 50
        0x7FFFF9DEL, 0x2C7B5848L, 0x63C7FD09L, 0x7144559CL, // 51
        0x7FFFFC50L, 0x2F236C2DL, 0x04B38B5DL, 0x67E03136L, // 52
        0x7FFFFDCDL, 0x7C5C8A99L, 0x47780740L, 0x3CCCFB89L, // 53
        0x7FFFFEB4L, 0x2E1E4A11L, 0x366AC9FCL, 0x2F9E887CL, // 54
        0x7FFFFF3EL, 0x0FEBD46FL, 0x6BC1CE85L, 0x72F069E7L, // 55
        0x7FFFFF8FL, 0x5B6E489EL, 0x28751892L, 0x56C780B5L, // 56
        0x7FFFFFBFL, 0x495E9E5FL, 0x7EAA1ACBL, 0x351B085FL, // 57
        0x7FFFFFDBL, 0x3057607BL, 0x28E384A2L, 0x5C5256A0L, // 58
        0x7FFFFFEBL, 0x3035C5A3L, 0x15A78AB7L, 0x0FC670CFL, // 59
        0x7FFFFFF4L, 0x3F4D8780L, 0x66D50D33L, 0x63B5CB00L, // 60
        0x7FFFFFF9L, 0x5212DCE2L, 0x6CD045D5L, 0x07DDE51EL, // 61
        0x7FFFFFFCL, 0x425CE8A8L, 0x02F46379L, 0x69404141L, // 62
        0x7FFFFFFEL, 0x0E49947FL, 0x0E07EA75L, 0x3B58DBEAL, // 63
        0x7FFFFFFEL, 0x7E1F309BL, 0x2F0778A7L, 0x2D18E896L, // 64
        0x7FFFFFFFL, 0x3ADDCA91L, 0x5A24C395L, 0x56E970E7L, // 65
        0x7FFFFFFFL, 0x5B8B8969L, 0x73D05913L, 0x5979C1D5L, // 66
        0x7FFFFFFFL, 0x6CF50016L, 0x4970EBFFL, 0x7B2F8760L, // 67
        0x7FFFFFFFL, 0x7625525CL, 0x0AF78928L, 0x125CBC7EL, // 68
        0x7FFFFFFFL, 0x7AF2D44BL, 0x4619F7B3L, 0x318AF6FCL, // 69
        0x7FFFFFFFL, 0x7D6F51AFL, 0x18D38DD1L, 0x73C75828L, // 70
        0x7FFFFFFFL, 0x7EB5AA16L, 0x20B148BBL, 0x23D956F8L, // 71
        0x7FFFFFFFL, 0x7F5B63C8L, 0x7DDB2AD8L, 0x2773EA98L, // 72
        0x7FFFFFFFL, 0x7FAEBE67L, 0x62813FEFL, 0x732DBF3BL, // 73
        0x7FFFFFFFL, 0x7FD8444FL, 0x2E032276L, 0x5B2AFA19L, // 74
        0x7FFFFFFFL, 0x7FECC0FAL, 0x55F8D363L, 0x07F7A470L, // 75
        0x7FFFFFFFL, 0x7FF6C3E2L, 0x30CFCC16L, 0x21550403L, // 76
        0x7FFFFFFFL, 0x7FFB9C50L, 0x5FBBDCD2L, 0x06635365L, // 77
        0x7FFFFFFFL, 0x7FFDEEEFL, 0x0D5AA5B2L, 0x756EF80AL, // 78
        0x7FFFFFFFL, 0x7FFF093FL, 0x0AEFA9CBL, 0x71B85E69L, // 79
        0x7FFFFFFFL, 0x7FFF8E00L, 0x09F364F6L, 0x34A17AD9L, // 80
        0x7FFFFFFFL, 0x7FFFCBD4L, 0x1CD513A4L, 0x5CB1E269L, // 81
        0x7FFFFFFFL, 0x7FFFE859L, 0x400469ACL, 0x7530AE2DL, // 82
        0x7FFFFFFFL, 0x7FFFF561L, 0x1F898BDBL, 0x04826122L, // 83
        0x7FFFFFFFL, 0x7FFFFB46L, 0x5697977EL, 0x7C47A5FCL, // 84
        0x7FFFFFFFL, 0x7FFFFDEBL, 0x14C7AD1BL, 0x6DFCE35AL, // 85
        0x7FFFFFFFL, 0x7FFFFF17L, 0x38F29E00L, 0x15864C26L, // 86
        0x7FFFFFFFL, 0x7FFFFF9BL, 0x3B053D45L, 0x67D04FC5L, // 87
        0x7FFFFFFFL, 0x7FFFFFD4L, 0x790609C5L, 0x5E96D840L, // 88
        0x7FFFFFFFL, 0x7FFFFFEDL, 0x5E4DD5C7L, 0x7D8F388AL, // 89
        0x7FFFFFFFL, 0x7FFFFFF8L, 0x29C05963L, 0x0645E13DL, // 90
        0x7FFFFFFFL, 0x7FFFFFFCL, 0x672F2508L, 0x3FCB5C26L, // 91
        0x7FFFFFFFL, 0x7FFFFFFEL, 0x57757A13L, 0x73F0B7CEL, // 92
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x3B2C73A1L, 0x6BA2B500L, // 93
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x6428E338L, 0x5026719CL, // 94
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x74D85FA8L, 0x5D9E5301L, // 95
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7B92AB00L, 0x044C95FAL, // 96
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7E42777FL, 0x7055A4A6L, // 97
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7F528317L, 0x1E611B26L, // 98
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FBD15BEL, 0x591E5FD1L, // 99
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FE66F66L, 0x4ED42CB5L, // 100
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FF65357L, 0x3C11F581L, // 101
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFC5FA6L, 0x13A72C4CL, // 102
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFEA751L, 0x0087E173L, // 103
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFF813CL, 0x68963485L, // 104
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFD1D2L, 0x6710A409L, // 105
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFEF56L, 0x56112414L, // 106
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFA0BL, 0x4B034EF2L, // 107
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFDE4L, 0x2CC83513L, // 108
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFF42L, 0x631F9BC7L, // 109
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFBEL, 0x23B1C1ECL, // 110
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFE9L, 0x32023A0BL, // 111
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFF8L, 0x25DDC591L, // 112
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFDL, 0x332A0006L, // 113
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x10BAC302L, // 114
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x5B278E34L, // 115
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x73EA444FL, // 116
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7C12EEC8L, // 117
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7EBC95AFL, // 118
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7F98EB43L, // 119
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FDF7528L, // 120
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FF5D2FBL, // 121
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFCD92AL, // 122
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFF087BL, // 123
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFB4CAL, // 124
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFE95DL, // 125
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFF940L, // 126
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFE02L, // 127
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFF6BL, // 128
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFD5L, // 129
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFF3L, // 130
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFCL, // 131
        0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, 0x7FFFFFFFL, // 132
    }; // cdt_v


    private static void kmxGauss(int[] z, int chunk, byte[] seed, int seedOffset, int nonce)
    {
        int[] sampk = new int[(CHUNK_SIZE + CDT_ROWS) * CDT_COLS];
        int[] sampg = new int[CHUNK_SIZE + CDT_ROWS];

        {
            // In the C Implementation they cast between uint_8 and int32 a lot, this is one of those situations.
            byte[] sampkBytes = new byte[sampk.length * 4];
            HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(
                sampkBytes, 0, CHUNK_SIZE * CDT_COLS * 4, (short)nonce, seed, seedOffset, CRYPTO_SEEDBYTES);
            int i, t;

            int offset = CHUNK_SIZE * CDT_COLS * 4;

            for (i = 0; i < cdt_v.length; i++)
            {
                sampkBytes[offset++] = (byte)(cdt_v[i]);
                sampkBytes[offset++] = (byte)(cdt_v[i] >>> 8);
                sampkBytes[offset++] = (byte)(cdt_v[i] >>> 16);
                sampkBytes[offset++] = (byte)(cdt_v[i] >>> 24);
            }

            for (i = 0, t = 0; t < sampkBytes.length; t += 4, i++)
            {
                sampk[i] = Pack.littleEndianToInt(sampkBytes, t);
            }

        }

        for (int i = 0; i < CHUNK_SIZE; i++)
        {
            sampg[i] = i << 16;
        }

        for (int i = 0; i < CDT_ROWS; i++)
        {
            sampg[CHUNK_SIZE + i] = (int)(0xFFFF0000L ^ i);
        }

        knuthMergeExchangeKG(sampk, sampg, CHUNK_SIZE + CDT_ROWS);

        int prev_inx = 0;
        for (int i = 0; i < CHUNK_SIZE + CDT_ROWS; i++)
        {
            int curr_inx = sampg[i] & 0xFFFF;
            // prev_inx < curr_inx => prev_inx - curr_inx < 0 => (prev_inx - curr_inx) >> 31 = 0xF...F else 0x0...0
            prev_inx ^= (curr_inx ^ prev_inx) & ((prev_inx - curr_inx) >> (RADIX32 - 1));
            int neg = (sampk[i * CDT_COLS] >> (RADIX - 1));  // Only the (so far unused) msb of the leading word
            sampg[i] |= ((neg & -prev_inx) ^ (~neg & prev_inx)) & 0xFFFFL;
        }

        knuthMergeExchangeG(sampg, CHUNK_SIZE + CDT_ROWS);

        for (int i = 0; i < CHUNK_SIZE; i++)
        {
            z[i + chunk] = (sampg[i] << (RADIX32 - 16)) >> (RADIX32 - 16);
        }

    }


    static void knuthMergeExchangeKG(int[] a, int g[], int n)
    {
        int t = 1;
        while (t < n - t)
        {
            t += t;
        }
        for (int p = t; p > 0; p >>= 1)
        {
            int apPtr = p * CDT_COLS;
            int a_iPtr = 0;
            int ap_iPtr = apPtr;
            int gpPtr = p;

            int neg = ~0;

            for (int i = 0; i < n - p; i++, a_iPtr += CDT_COLS, ap_iPtr += CDT_COLS)
            {
                if (!((i & p) != 0))
                {
                    {
                        int diff = 0, swapa;
                        int swapg;
                        {
                            {
                                diff = (diff + (a[ap_iPtr + 3] & ((neg >>> 1))) - (a[a_iPtr + 3] & ((neg >>> 1)))) >> (32 - 1);
                            }
                            ;
                            {
                                {
                                    diff = (diff + (a[ap_iPtr + 2] & (neg >>> 1))) - (a[a_iPtr + 2] & ((neg >>> 1))) >> (32 - 1);
                                }
                                ;
                                {
                                    {
                                        diff = (diff + (a[ap_iPtr + 1] & (neg >>> 1))) - (a[a_iPtr + 1] & ((neg >>> 1))) >> (32 - 1);
                                    }
                                    ;
                                    {
                                        {
                                            diff = (diff + (a[ap_iPtr] & ((neg >>> 1))) - (a[a_iPtr] & ((neg >>> 1)))) >> (32 - 1);
                                        }
                                        ;
                                        {
                                            swapa = (a[a_iPtr] ^ a[ap_iPtr]) & diff;
                                            a[a_iPtr] ^= swapa;
                                            a[ap_iPtr] ^= swapa;
                                        }
                                        ;
                                    }
                                    ;
                                    {
                                        swapa = (a[a_iPtr + 1] ^ a[ap_iPtr + 1]) & diff;
                                        a[a_iPtr + 1] ^= swapa;
                                        a[ap_iPtr + 1] ^= swapa;
                                    }
                                    ;
                                }
                                ;
                                {
                                    swapa = (a[a_iPtr + 2] ^ a[ap_iPtr + 2]) & diff;
                                    a[a_iPtr + 2] ^= swapa;
                                    a[ap_iPtr + 2] ^= swapa;
                                }
                                ;
                            }
                            ;
                            {
                                swapa = (a[a_iPtr + 3] ^ a[ap_iPtr + 3]) & diff;
                                a[a_iPtr + 3] ^= swapa;
                                a[ap_iPtr + 3] ^= swapa;
                            }
                            ;
                        }
                        ;
                        {
                            swapg = (g[i] ^ g[gpPtr + i]) & diff;
                            g[i] ^= swapg;
                            g[gpPtr + i] ^= swapg;
                        }
                        ;
                    }
                    ;
                }
            }


            for (int q = t; q > p; q >>= 1)
            {
                int ap_iPtr_ = apPtr;
                int aq_iPtr = q * CDT_COLS;
                int gqPtr = q;
                for (int i = 0; i < n - q; i++, ap_iPtr_ += CDT_COLS, aq_iPtr += CDT_COLS)
                {
                    if (!((i & p) != 0))
                    {
                        {
                            int diff = 0, swapa;
                            int swapg;
                            {
                                {
                                    diff = (diff + (a[aq_iPtr + 3] & (neg >>> 1))) - (a[ap_iPtr_ + 3] & (neg >>> 1)) >> (32 - 1);
                                }
                                ;
                                {
                                    {
                                        diff = (diff + (a[aq_iPtr + 2] & (neg >>> 1))) - (a[ap_iPtr_ + 2] & (neg >>> 1)) >> (32 - 1);
                                    }
                                    ;
                                    {
                                        {
                                            diff = (diff + (a[aq_iPtr + 1] & (neg >>> 1))) - (a[ap_iPtr_ + 1] & (neg >>> 1)) >> (32 - 1);
                                        }
                                        ;
                                        {
                                            {
                                                diff = (diff + (a[aq_iPtr] & (neg >>> 1))) - (a[ap_iPtr_] & (neg >>> 1)) >> (32 - 1);
                                            }
                                            ;
                                            {
                                                swapa = (a[ap_iPtr_] ^ a[aq_iPtr]) & diff;
                                                a[ap_iPtr_] ^= swapa;
                                                a[aq_iPtr] ^= swapa;
                                            }
                                            ;
                                        }
                                        ;
                                        {
                                            swapa = (a[ap_iPtr_ + 1] ^ a[aq_iPtr + 1]) & diff;
                                            a[ap_iPtr_ + 1] ^= swapa;
                                            a[aq_iPtr + 1] ^= swapa;
                                        }
                                        ;
                                    }
                                    ;
                                    {
                                        swapa = (a[ap_iPtr_ + 2] ^ a[aq_iPtr + 2]) & diff;
                                        a[ap_iPtr_ + 2] ^= swapa;
                                        a[aq_iPtr + 2] ^= swapa;
                                    }
                                    ;
                                }
                                ;
                                {
                                    swapa = (a[ap_iPtr_ + 3] ^ a[aq_iPtr + 3]) & diff;
                                    a[ap_iPtr_ + 3] ^= swapa;
                                    a[aq_iPtr + 3] ^= swapa;
                                }
                                ;
                            }
                            ;
                            {
                                swapg = (g[gpPtr + i] ^ g[gqPtr + i]) & diff;
                                g[gpPtr + i] ^= swapg;
                                g[gqPtr + i] ^= swapg;
                            }
                            ;
                        }
                        ;

                    }
                }
            }

        }
    }


    static void knuthMergeExchangeG(int a[], int n)
    {
        int t = 1;
        while (t < n - t)
        {
            t += t;
        }
        for (int p = t; p > 0; p >>= 1)
        {

            int apPtr = p;
            for (int i = 0; i < n - p; i++)
            {
                if (!((i & p) != 0))
                {
                    int diff = ((a[apPtr + i] & 0x7FFFFFFF) - (a[i] & 0x7FFFFFFF)) >> (32 - 1);
                    int swap = (a[i] ^ a[apPtr + i]) & diff;
                    a[i] ^= swap;
                    a[apPtr + i] ^= swap;
                }
            }

            for (int q = t; q > p; q >>= 1)
            {
                int aqPtr = q;
                for (int i = 0; i < n - q; i++)
                {
                    if (!((i & p) != 0))
                    {
                        int diff = ((a[aqPtr + i] & 0x7FFFFFFF) - (a[apPtr + i] & 0x7FFFFFFF)) >> (32 - 1);
                        int swap = (a[apPtr + i] ^ a[aqPtr + i]) & diff;
                        a[apPtr + i] ^= swap;
                        a[aqPtr + i] ^= swap;
                    }
                }
            }
        }
    }

    static int load32(final byte[] load, int loadOffset)
    {

        int number = 0;

        if (load.length - loadOffset >= 4)
        {

            for (int i = 0; i < 4; i++)
            {

                number ^= (int)(load[loadOffset + i] & 0xFF) << (8 * i);

            }

        }
        else
        {


            for (int i = 0; i < load.length - loadOffset; i++)
            {

                number ^= (int)(load[loadOffset + i] & 0xFF) << (8 * i);

            }

        }

        return number;

    }

    static void store32(byte[] store, int storeOffset, int number)
    {

        if (store.length - storeOffset >= 4)
        {

            for (int i = 0; i < 4; i++)
            {

                store[storeOffset + i] = (byte)((number >> (8 * i)) & 0xFF);

            }

        }
        else
        {

            for (int i = 0; i < store.length - storeOffset; i++)
            {

                store[storeOffset + i] = (byte)((number >> (8 * i)) & 0xFF);

            }

        }

    }

    //TODO use Arrays lib.
    static boolean memoryEqual(byte[] left, int leftOffset, byte[] right, int rightOffset, int length)
    {

        if ((leftOffset + length <= left.length) && (rightOffset + length <= right.length))
        {

            for (int i = 0; i < length; i++)
            {

                if (left[leftOffset + i] != right[rightOffset + i])
                {

                    return false;

                }

            }

            return true;

        }
        else
        {

            return false;

        }

    }


    static class QTesla3Polynomial
    {

        /****************************************************************************
         * Description:	Montgomery Reduction for Heuristic qTESLA Security Category 1
         * 				and Security Category-3 (Option for Size and Speed)
         *
         * @param        number        Number to be Reduced
         *
         * @return Reduced Number
         ****************************************************************************/
        static int montgomery(long number)
        {


            return (int)((number + ((number * Q_INVERSE) & 0xFFFFFFFFL) * Q) >> 32);

        }

        /****************************************************************************
         * Description:	Montgomery Reduction for Provably-Secure qTESLA
         * 				Security Category-1 and Security Category-3
         *
         * @param        number        Number to be Reduced
         *
         * @return Reduced Number
         ****************************************************************************/
        private static long montgomeryP(long number)
        {

            return (number + ((number * Q_INVERSE) & 0xFFFFFFFFL) * Q) >> 32;

        }

        /**********************************************************************************************
         * Description:	Barrett Reduction for Heuristic qTESLA Security Category-3
         * 				(Option for Size or Speed)
         *
         * @param        number                    Number to be Reduced
         *
         * @return Reduced Number
         **********************************************************************************************/
        static int barrett(int number)
        {

            return number - (int)(((long)number * BARRETT_MULTIPLICATION) >> BARRETT_DIVISION) * Q;

        }

        /*************************************************************************************************
         * Description:	Barrett Reduction for Provably-Secure qTESLA Security Category-1 and
         * 				Security Category-3
         *
         * @param        number                    Number to be Reduced
         * @param        barrettMultiplication
         * @param        barrettDivision
         * @param        q                        Modulus
         *
         * @return Reduced Number
         *************************************************************************************************/
        static long barrett(long number, int q, int barrettMultiplication, int barrettDivision)
        {

            return number - ((number * barrettMultiplication) >> barrettDivision) * q;

        }

        /************************************************************************************************************
         * Description:	Forward Number Theoretic Transform for Heuristic qTESLA Security Category-1,
         * 				Security Category-3 (Option for Size and Speed)
         *
         * @param        destination        Destination of Transformation
         * @param        source            Source of Transformation
         * @param        n                Polynomial Degree
         * @param        q                Modulus
         * @param        qInverse
         *
         * @return none
         ************************************************************************************************************/
        private static void numberTheoreticTransform(int destination[], int source[], int n, int q, long qInverse)
        {

            int jTwiddle = 0;
            int numberOfProblem = n >> 1;

            for (; numberOfProblem > 0; numberOfProblem >>= 1)
            {

                int j = 0;
                int jFirst;

                for (jFirst = 0; jFirst < n; jFirst = j + numberOfProblem)
                {

                    long omega = source[jTwiddle++];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {
                        int temporary = montgomery(omega * destination[j + numberOfProblem]);
                        destination[j + numberOfProblem] = destination[j] - temporary;
                        destination[j] = destination[j] + temporary;

                    }

                }

            }

        }

        /**************************************************************************************************************
         * Description:	Forward Number Theoretic Transform for Provably-Secure qTESLA Security Category-1
         *
         * @param        destination        Destination of Transformation
         * @param        source            Source of Transformation
         *
         * @return none
         **************************************************************************************************************/
        private static void numberTheoreticTransformIP(long destination[], long source[])
        {

            int numberOfProblem = PARAM_N >> 1;
            int jTwiddle = 0;

            for (; numberOfProblem > 0; numberOfProblem >>= 1)
            {

                int j = 0;
                int jFirst;

                for (jFirst = 0; jFirst < PARAM_N; jFirst = j + numberOfProblem)
                {

                    long omega = source[jTwiddle++];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {

                        long temporary = montgomeryP(
                            omega * destination[j + numberOfProblem]
                        );

                        destination[j + numberOfProblem] = destination[j] + (Q - temporary);

                        destination[j] = destination[j] + temporary;

                    }

                }

            }

        }

        /**************************************************************************************************************
         * Description:	Forward Number Theoretic Transform for Provably-Secure qTESLA Security Category-3
         *
         * @param        destination        Destination of Transformation
         * @param        source            Source of Transformation
         *
         * @return none
         **************************************************************************************************************/
        private static void numberTheoreticTransformIIIP(long destination[], long source[])
        {

            int jTwiddle = 0;
            int numberOfProblem = PARAM_N >> 1;

            for (; numberOfProblem > 0; numberOfProblem >>= 1)
            {

                int j = 0;
                int jFirst;

                for (jFirst = 0; jFirst < PARAM_N; jFirst = j + numberOfProblem)
                {

                    int omega = (int)source[jTwiddle++];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {

                        long temporary = barrett(
                            montgomeryP(
                                omega * destination[j + numberOfProblem]
                            ),
                            Q,
                            BARRETT_MULTIPLICATION,
                            BARRETT_DIVISION
                        );

                        destination[j + numberOfProblem] = barrett(
                            destination[j] + (2L * Q - temporary),
                            Q,
                            BARRETT_MULTIPLICATION,
                            BARRETT_DIVISION
                        );

                        destination[j] = barrett(
                            destination[j] + temporary,
                            Q,
                            BARRETT_MULTIPLICATION,
                            BARRETT_DIVISION
                        );

                    }

                }

            }

        }

        /******************************************************************************************************************


         /**************************************************************************************************************************************************************************
         * Description:	Inverse Number Theoretic Transform for Heuristic qTESLA Security Category-3 (Option for Size and Speed)
         *
         * @param        destination                    Destination of Inverse Transformation
         * @param        source                        Source of Inverse Transformation
         *
         * @return none
         **************************************************************************************************************************************************************************/
        private static void inverseNumberTheoreticTransform(int destination[], int source[])
        {

            int jTwiddle = 0;

            for (int numberOfProblem = 1; numberOfProblem < PARAM_N; numberOfProblem *= 2)
            {

                int j = 0;

                for (int jFirst = 0; jFirst < PARAM_N; jFirst = j + numberOfProblem)
                {

                    long omega = source[jTwiddle++];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {

                        int temporary = destination[j];

                        if (numberOfProblem == 16)
                        {

                            destination[j] = barrett(temporary + destination[j + numberOfProblem]);

                        }
                        else
                        {

                            destination[j] = temporary + destination[j + numberOfProblem];

                        }

                        destination[j + numberOfProblem] = montgomery(omega * (temporary - destination[j + numberOfProblem]));

                    }

                }

            }

            for (int i = 0; i < PARAM_N / 2; i++)
            {

                destination[i] = montgomery((long)R * destination[i]);

            }

        }

        /***********************************************************************************************************************************************************************************
         * Description:	Inverse Number Theoretic Transform for Provably-Secure qTESLA Security Category-1
         *
         * @param        destination            Destination of Inverse Transformation
         * @param        destinationOffset    Starting Point of the Destination
         * @param        source                Source of Inverse Transformation
         * @param        sourceOffset        Starting Point of the Source
         *
         * @return none
         ***********************************************************************************************************************************************************************************/
        private static void inverseNumberTheoreticTransformIP(long destination[], int destinationOffset, long source[], int sourceOffset)
        {

            int jTwiddle = 0;

            for (int numberOfProblem = 1; numberOfProblem < PARAM_N; numberOfProblem *= 2)
            {

                int j = 0;
                int jFirst;

                for (jFirst = 0; jFirst < PARAM_N; jFirst = j + numberOfProblem)
                {

                    long omega = source[sourceOffset + (jTwiddle++)];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {

                        long temporary = destination[destinationOffset + j];

                        destination[destinationOffset + j] = temporary + destination[destinationOffset + j + numberOfProblem];

                        destination[destinationOffset + j + numberOfProblem] = montgomeryP(
                            omega * (temporary + (2L * Q - destination[destinationOffset + j + numberOfProblem]))
                        );

                    }

                }

                numberOfProblem *= 2;

                for (jFirst = 0; jFirst < PARAM_N; jFirst = j + numberOfProblem)
                {

                    long omega = source[sourceOffset + (jTwiddle++)];

                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
                    {

                        long temporary = destination[destinationOffset + j];

                        destination[destinationOffset + j] = barrett(
                            temporary + destination[destinationOffset + j + numberOfProblem],
                            Q, BARRETT_MULTIPLICATION, BARRETT_DIVISION
                        );

                        destination[destinationOffset + j + numberOfProblem] = montgomeryP(
                            omega * (temporary + (2L * Q - destination[destinationOffset + j + numberOfProblem]))
                        );

                    }

                }

            }

        }

//        /******************************************************************************************************************************************************************************************
//         * Description:	Inverse Number Theoretic Transform for Provably-Secure qTESLA Security Category-3
//         *
//         * @param        destination            Destination of Inverse Transformation
//         * @param        destinationOffset    Starting Point of the Destination
//         * @param        source                Source of Inverse Transformation
//         * @param        sourceOffset        Starting Point of the Source
//         *
//         * @return none
//         ******************************************************************************************************************************************************************************************/
//        private static void inverseNumberTheoreticTransformIIIP(long destination[], int destinationOffset, long source[], int sourceOffset)
//        {
//
//            int jTwiddle = 0;
//
//            for (int numberOfProblem = 1; numberOfProblem < Parameter.N_III_P; numberOfProblem *= 2)
//            {
//
//                int j = 0;
//                int jFirst;
//
//                for (jFirst = 0; jFirst < Parameter.N_III_P; jFirst = j + numberOfProblem)
//                {
//
//                    long omega = source[sourceOffset + (jTwiddle++)];
//
//                    for (j = jFirst; j < jFirst + numberOfProblem; j++)
//                    {
//
//                        long temporary = destination[destinationOffset + j];
//
//                        destination[destinationOffset + j] = barrett(
//                            temporary + destination[destinationOffset + j + numberOfProblem],
//                            Parameter.Q_III_P, Parameter.BARRETT_MULTIPLICATION_III_P, Parameter.BARRETT_DIVISION_III_P
//                        );
//
//                        destination[destinationOffset + j + numberOfProblem] = barrett(
//                            montgomeryP(
//                                omega * (temporary + (2L * Q - destination[destinationOffset + j + numberOfProblem]))),
//                            Parameter.Q_III_P, Parameter.BARRETT_MULTIPLICATION_III_P, Parameter.BARRETT_DIVISION_III_P
//                        );
//
//                    }
//
//                }
//
//            }
//
//        }

        /****************************************************************************************************************************************************
         * Description:	Component Wise Polynomial Multiplication for Heuristic qTESLA Security Category-1 and Security Category-3 (Option for Size and Speed)
         *
         * @param        product                    Product = Multiplicand (*) Multiplier
         * @param        multiplicand            Multiplicand Array
         * @param        multiplier                Multiplier Array
         * @param        n                        Polynomial Degree
         * @param        q                        Modulus
         * @param        qInverse
         *
         * @return none
         ****************************************************************************************************************************************************/
        private static void componentWisePolynomialMultiplication(int[] product, int[] multiplicand, int[] multiplier, int n, int q, long qInverse)
        {

            for (int i = 0; i < n; i++)
            {

                product[i] = montgomery((long)multiplicand[i] * multiplier[i]);

            }

        }

        /******************************************************************************************************************************************************************************************************************
         * Description:	Component Wise Polynomial Multiplication for Provably-Secure qTESLA Security Category-1 and Security Category-3
         *
         * @param        product                    Product = Multiplicand (*) Multiplier
         * @param        productOffset            Starting Point of the Product Array
         * @param        multiplicand            Multiplicand Array
         * @param        multiplicandOffset        Starting Point of the Multiplicand Array
         * @param        multiplier                Multiplier Array
         * @param        multiplierOffset        Starting Point of the Multiplier Array
         * @param        n                        Polynomial Degree
         * @param        q                        Modulus
         * @param        qInverse
         *
         * @return none
         ******************************************************************************************************************************************************************************************************************/
        private static void componentWisePolynomialMultiplication(long[] product, int productOffset, long[] multiplicand, int multiplicandOffset, long[] multiplier, int multiplierOffset, int n, int q, long qInverse)
        {

            for (int i = 0; i < n; i++)
            {

                product[productOffset + i] = montgomeryP(multiplicand[multiplicandOffset + i] * multiplier[multiplierOffset + i]);

            }

        }

        /***********************************************************************************************************************************************
         * Description:	Polynomial Number Theoretic Transform for Provably-Secure qTESLA Security Category-1 and Category-3
         *
         * @param        arrayNumberTheoreticTransform        Transformed Array
         * @param        array                                Array to be Transformed
         * @param        n                                    Polynomial Degree
         *
         * @return none
         ***********************************************************************************************************************************************/
//        static void polynomialNumberTheoreticTransform(long[] arrayNumberTheoreticTransform, long[] array, int n)
//        {
//
//            for (int i = 0; i < n; i++)
//            {
//
//                arrayNumberTheoreticTransform[i] = array[i];
//
//            }
//
//            if (n == PARAM_N)
//            {
//
//                numberTheoreticTransformIP(arrayNumberTheoreticTransform, ZETA);
//
//            }
//
////            if (n == Parameter.N_III_P)
////            {
////
////                numberTheoreticTransformIIIP(arrayNumberTheoreticTransform, ZETA);  PolynomialProvablySecure.ZETA_III_P);
////
////           // }
//
//        }

        /*******************************************************************************************************************************************
         * Description:	Polynomial Multiplication for Heuristic qTESLA Security Category-1 and Category-3 (Option for Size and Speed)
         *
         * @param        product                    Product = Multiplicand * Multiplier
         * @param        multiplicand            Multiplicand Array
         * @param        multiplier                Multiplier Array
         * @param        n                        Polynomial Degree
         * @param        q                        Modulus
         * @param        qInverse
         * @param        zeta
         *
         * @return none
         *******************************************************************************************************************************************/
        static void polynomialMultiplication(int[] product, int[] multiplicand, int[] multiplier, int n, int q, long qInverse, int[] zeta)
        {

            int[] multiplierNumberTheoreticTransform = new int[n];

            for (int i = 0; i < n; i++)
            {

                multiplierNumberTheoreticTransform[i] = multiplier[i];

            }


            numberTheoreticTransform(multiplierNumberTheoreticTransform, zeta, n, q, qInverse);

            componentWisePolynomialMultiplication(product, multiplicand, multiplierNumberTheoreticTransform, n, q, qInverse);

            inverseNumberTheoreticTransform(
                product, ZETA_INVERSE
            );


        }

        /***************************************************************************************************************************************************************************************************
         * Description:	Polynomial Multiplication for Provably-Secure qTESLA Security Category-1 and Category-3
         *
         * @param        product                    Product = Multiplicand * Multiplier
         * @param        productOffset            Starting Point of the Product Array
         * @param        multiplicand            Multiplicand Array
         * @param        multiplicandOffset        Starting Point of the Multiplicand Array
         * @param        multiplier                Multiplier Array
         * @param        multiplierOffset        Starting Point of the Multiplier Array
         * @param        n                        Polynomial Degree
         * @param        q                        Modulus
         * @param        qInverse
         *
         * @return none
         ***************************************************************************************************************************************************************************************************/
        //   static void polynomialMultiplication(long[] product, int productOffset, long[] multiplicand, int multiplicandOffset, long[] multiplier, int multiplierOffset, int n, int q, long qInverse)
//        {
//
//            componentWisePolynomialMultiplication(product, productOffset, multiplicand, multiplicandOffset, multiplier, multiplierOffset, n, q, qInverse);
//
//            if (q == Parameter.Q_I_P)
//            {
//
//                inverseNumberTheoreticTransformIP(product, productOffset, PolynomialProvablySecure.ZETA_INVERSE_I_P, 0);
//
//            }
//
//            if (q == Parameter.Q_III_P)
//            {
//
//                inverseNumberTheoreticTransformIIIP(product, productOffset, PolynomialProvablySecure.ZETA_INVERSE_III_P, 0);
//
//            }
//
//        }

        /****************************************************************************************************************************************************
         * Description:	Polynomial Addition for Heuristic qTESLA Security Category-1 and Category-3 (Option for Size or Speed)
         * 				Q + L_E < 2 ^ (CEIL (LOGARITHM (Q, 2)))
         * 				No Necessary Reduction for Y + SC
         *
         * @param        summation            Summation = Augend + Addend
         * @param        augend                Augend Array
         * @param        addend                Addend Array
         * @param        n                    Polynomial Degree
         *
         * @return none
         ****************************************************************************************************************************************************/
        static void polynomialAddition(int[] summation, int[] augend, int[] addend, int n)
        {

            for (int i = 0; i < n; i++)
            {

                summation[i] = augend[i] + addend[i];

            }

        }

        /********************************************************************************************************************************************************
         * Description:	Polynomial Addition for Provably-Secure qTESLA Security Category-1 and Category-3
         * 				Q + L_E < 2 ^ (CEIL (LOGARITHM (Q, 2)))
         * 				No Necessary Reduction for Y + SC
         *
         * @param        summation            Summation = Augend + Addend
         * @param        summationOffset        Starting Point of the Summation Array
         * @param        augend                Augend Array
         * @param        augendOffset        Starting Point of the Augend Array
         * @param        addend                Addend Array
         * @param        addendOffset        Starting Point of the Addend Array
         * @param        n                    Polynomial Degree
         *
         * @return none
         ********************************************************************************************************************************************************/
        static void polynomialAddition(long[] summation, int summationOffset, long[] augend, int augendOffset, long[] addend, int addendOffset, int n)
        {

            for (int i = 0; i < n; i++)
            {

                summation[summationOffset + i] = augend[augendOffset + i] + addend[addendOffset + i];

            }

        }

        /*************************************************************************************************************
         * Description:	Polynomial Addition with Correction for Heuristic qTESLA Security Category-1 and Category-3
         * 				(Option for Size or Speed)
         * 				Q + L_E < 2 ^ (CEIL (LOGARITHM (Q, 2)))
         * 				No Necessary Reduction for Y + SC
         *
         * @param        summation            Summation = Augend + Addend
         * @param        augend                Augend Array
         * @param        addend                Addend Array
         * @param        n                    Polynomial Degree
         *
         * @return none
         ************************************************************************************************************/
        static void polynomialAdditionCorrection(int[] summation, int[] augend, int[] addend, int n, int q)
        {

            for (int i = 0; i < n; i++)
            {

                summation[i] = augend[i] + addend[i];
                /* If summation[i] < 0 Then Add Q */
                summation[i] += (summation[i] >> 31) & q;
                summation[i] -= q;
                /* If summation[i] >= Q Then Subtract Q */
                summation[i] += (summation[i] >> 31) & q;

            }

        }

        /**********************************************************************************************************************
         * Description:	Polynomial Subtraction with Correction for Heuristic qTESLA Security Category-1 and Security Category-3
         *				(Option for Size or Speed)
         *
         * @param        difference                    Difference = Minuend (-) Subtrahend
         * @param        minuend                        Minuend Array
         * @param        subtrahend                    Subtrahend Array
         *
         * @return none
         ***********************************************************************************************************************/
        static void polynomialSubtractionCorrection(int[] difference, int[] minuend, int[] subtrahend)
        {

            for (int i = 0; i < PARAM_N; i++)
            {

                difference[i] = minuend[i] - subtrahend[i];
                /* If difference[i] < 0 Then Add Q */
                difference[i] += (difference[i] >> 31) & Q;

            }

        }

        /*******************************************************************************************************************************************
         * Description:	Polynomial Subtraction with Montgomery Reduction for Heuristic qTESLA Security Category-1 and Security Category-3
         *				(Option for Size or Speed)
         *
         * @param        difference                    Difference = Minuend (-) Subtrahend
         * @param        minuend                        Minuend Array
         * @param        subtrahend                    Subtrahend Array
         *
         * @return none
         *******************************************************************************************************************************************/
        static void polynomialSubtractionMontgomery(int[] difference, int[] minuend, int[] subtrahend)
        {

            for (int i = 0; i < PARAM_N; i++)
            {

                difference[i] = montgomery((long)R * (minuend[i] - subtrahend[i]));

            }

        }

        /******************************************************************************************************************************************************************************************************************************
         * Description:	Polynomial Subtraction for Provably-Secure qTESLA Security Category-1 and Security Category-3
         *
         * @param        difference                    Difference = Minuend (-) Subtrahend
         * @param        differenceOffset            Starting Point of the Difference Array
         * @param        minuend                        Minuend Array
         * @param        minuendOffset                Starting Point of the Minuend Array
         * @param        subtrahend                    Subtrahend Array
         * @param        subtrahendOffset            Starting Point of the Subtrahend Array
         * @param        n                            Polynomial Degree
         * @param        q                            Modulus
         * @param        barrettMultiplication
         * @param        barrettDivision
         *
         * @return none
         ******************************************************************************************************************************************************************************************************************************/
        static void polynomialSubtraction(long[] difference, int differenceOffset, long[] minuend, int minuendOffset, long[] subtrahend, int subtrahendOffset, int n, int q, int barrettMultiplication, int barrettDivision)
        {

            for (int i = 0; i < n; i++)
            {

                difference[differenceOffset + i] = barrett(minuend[minuendOffset + i] - subtrahend[subtrahendOffset + i], q, barrettMultiplication, barrettDivision);

            }

        }

        /******************************************************************************************************************************************************************************
         * Description:	Generation of Polynomial A for Heuristic qTESLA Security Category-1 and Security Category-3 (Option for Size or Speed)
         *
         * @param        A                                    Polynomial to be Generated
         * @param        seed                                Kappa-Bit Seed
         * @param        seedOffset                            Starting Point of the Kappa-Bit Seed
         *
         * @return none
         ******************************************************************************************************************************************************************************/
        static void polynomialUniform(int[] A, byte[] seed, int seedOffset)
        {


            int position = 0;
            int i = 0;
            int numberOfByte = (Q_LOGARITHM + 7) / 8;
            int numberOfBlock = GENERATOR_A;
            short dualModeSampler = 0;
            int value1;
            int value2;
            int value3;
            int value4;
            int mask = (1 << Q_LOGARITHM) - 1;

            byte[] buffer = new byte[HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE * GENERATOR_A];

            HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(
                buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE * GENERATOR_A,
                dualModeSampler++,
                seed, seedOffset, CRYPTO_RANDOMBYTES
            );


            while (i < PARAM_N)
            {

                if (position > (HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE * numberOfBlock - 4 * numberOfByte))
                {

                    numberOfBlock = 1;

                    HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(
                        buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE * numberOfBlock,
                        dualModeSampler++,
                        seed, seedOffset, CRYPTO_RANDOMBYTES
                    );

                    position = 0;

                }

                value1 = load32(buffer, position) & mask;
                position += numberOfByte;

                value2 = load32(buffer, position) & mask;
                position += numberOfByte;

                value3 = load32(buffer, position) & mask;
                position += numberOfByte;

                value4 = load32(buffer, position) & mask;
                position += numberOfByte;

                if (value1 < Q && i < PARAM_N)
                {
                    A[i++] = montgomery((long)value1 * INVERSE_NUMBER_THEORETIC_TRANSFORM);
                }

                if (value2 < Q && i < PARAM_N)
                {
                    A[i++] = montgomery((long)value2 * INVERSE_NUMBER_THEORETIC_TRANSFORM);
                }

                if (value3 < Q && i < PARAM_N)
                {
                    A[i++] = montgomery((long)value3 * INVERSE_NUMBER_THEORETIC_TRANSFORM);
                }

                if (value4 < Q && i < PARAM_N)
                {
                    A[i++] = montgomery((long)value4 * INVERSE_NUMBER_THEORETIC_TRANSFORM);
                }

            }

        }


        /**************************************************************************************************************************************************************
         * Description:	Performs Sparse Polynomial Multiplication for A Value Needed During Message Signification for Heuristic qTESLA Security Category-1 and
         *				SecurityCategory-3 (Option for Size or Speed)
         *
         * @param        product                Product of Two Polynomials
         * @param        privateKey            Part of the Private Key
         * @param        positionList        List of Indices of Non-Zero Elements in C
         * @param        signList            List of Signs of Non-Zero Elements in C
         *
         * @return none
         **************************************************************************************************************************************************************/
        static void sparsePolynomialMultiplication16(int[] product, final short[] privateKey, final int[] positionList, final short[] signList)
        {

            int position;

            Arrays.fill(product, 0);

            for (int i = 0; i < PARAM_H; i++)
            {

                position = positionList[i];

                for (int j = 0; j < position; j++)
                {

                    product[j] -= signList[i] * privateKey[PARAM_N + j - position];

                }

                for (int j = position; j < PARAM_N; j++)
                {

                    product[j] += signList[i] * privateKey[j - position];

                }

            }

        }

        /*****************************************************************************************************************************************************************************************************
         * Description:	Performs Sparse Polynomial Multiplication for A Value Needed During Message Signification for Provably-Secure qTESLA Security Category-1 and Category-3
         *
         * @param        product                Product of Two Polynomials
         * @param        productOffset        Starting Point of the Product of Two Polynomials
         * @param        privateKey            Part of the Private Key
         * @param        privateKeyOffset    Starting Point of the Private Key
         * @param        positionList        List of Indices of Non-Zero Elements in C
         * @param        signList            List of Signs of Non-Zero Elements in C
         * @param        n                    Polynomial Degree
         * @param        h                    Number of Non-Zero Entries of Output Elements of Encryption
         *
         * @return none
         ******************************************************************************************************************************************************************************************************/
        static void sparsePolynomialMultiplication8(long[] product, int productOffset, final byte[] privateKey, int privateKeyOffset, final int[] positionList, final short[] signList, int n, int h)
        {

            int position;

            Arrays.fill(product, 0L);

            for (int i = 0; i < h; i++)
            {

                position = positionList[i];

                for (int j = 0; j < position; j++)
                {

                    product[productOffset + j] -= signList[i] * privateKey[privateKeyOffset + n + j - position];

                }

                for (int j = position; j < n; j++)
                {

                    product[productOffset + j] += signList[i] * privateKey[privateKeyOffset + j - position];

                }

            }

        }

        /***********************************************************************************************************************************************************
         * Description:	Performs Sparse Polynomial Multiplication for A Value Needed During Message Signification for Heuristic qTESLA Security Category-1 and
         * 				Security Category-3 (Option for Size or Speed)
         *
         * @param        product                    Product of Two Polynomials
         * @param        publicKey                Part of the Public Key
         * @param        positionList            List of Indices of Non-Zero Elements in C
         * @param        signList                List of Signs of Non-Zero Elements in C
         * @return none
         ***********************************************************************************************************************************************************/
        static void sparsePolynomialMultiplication32(int[] product, final int[] publicKey, final int[] positionList, final short[] signList)
        {

            int position;

            Arrays.fill(product, 0);

            for (int i = 0; i < PARAM_H; i++)
            {

                position = positionList[i];

                for (int j = 0; j < position; j++)
                {
                    product[j] -= (signList[i] * publicKey[PARAM_N + j - position]);
                }

                for (int j = position; j < PARAM_N; j++)
                {
                    product[j] += signList[i] * publicKey[j - position];
                }

            }

        }


    }


}
